//@version=5
// ?î‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê??
// ??Îß§ÏßÅ1Î∂ÑVN ??Python Î∞±ÌÖå?§Ìä∏ ?îÏßÑÍ≥??ôÎì±??TradingView ÏµúÏ¢ÖÎ≥?(?àÍ≤¨?∏Ìñ• ?òÏ†ï) ??
// ???êÎ≥∏ Python Íµ¨ÌòÑ??Pine Script v5 Î°?1:1 Î°úÏßÅ ?¥Ïãù??Î≤ÑÏ†Ñ               ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ??
// ??Author: OpenAI gpt-5-codex (for Basemodule ?ÑÎ°ú?ùÌä∏)                  ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†??
// ?ö‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê?ê‚ïê??
// Gemini ?òÏ†ï (2025-10-10): f_htf ?®Ïàò Î∞?Í¥Ä???∏Ï∂úÎ∂Ä ?òÏ†ï (request.security mutable variable ?êÎü¨ ?¥Í≤∞)
// ?í° Î¶¨Ìéò?∏ÌåÖ ?òÏ†ï (2025-10-10): f_htf ???ÅÏúÑ ?Ä?ÑÌîÑ?àÏûÑ ?ïÏ†ï Í∞íÎßå ?¨Ïö©?òÎèÑÎ°??§ÏãúÍ∞?Íµ¨Í∞Ñ???úÌï¥ ?¥Ï†Ñ Î¥âÏúºÎ°??êÎèô Î≥¥Ï†ï (Í≤ΩÍ≥† ?úÍ±∞ & Non-Repainting ?†Ï?)
// ?êû Î°úÏßÅ ?òÏ†ï (2025-10-11): 'Deluxe' Î∞?'KC' Î™®Î©ò?Ä ?§Ì????ïÍ∑ú??Î°úÏßÅ ?ÑÎùΩ ?òÏ†ï (Gemini)
// ??Í∏∞Îä• Ï∂îÍ? (?¨Ïö©???îÏ≤≠): Í≥†Ï†ï ?êÏ†à %?®ÏúÑ Î≥ÄÍ≤? ?πÎì§Î¶¨Ïóê Î∞??åÎùºÎ≥ºÎ¶≠ SAR Ï∂úÍµ¨ ?ÑÎûµ Ï∂îÍ?
// ?îß Î≤ÑÍ∑∏ ?òÏ†ï (2025-10-12): HUD ?åÏù¥Î∏?Í¥Ä??Î≥Ä?òÎ™Ö ?§Ì? ?òÏ†ï (Gemini)
strategy('?µÌï©Î™®Î©ò?Ä (Python ?¨Ìä∏) - ÏµúÏ¢Ö ?òÏ†ïÎ≥?,
         overlay=true,
         process_orders_on_close=true,
         calc_on_every_tick=false,          // Ï¢ÖÍ? Í∏∞Ï? Í≥ÑÏÇ∞?ºÎ°ú ?ºÍ???Í∞ïÌôî
   
         pyramiding=1,
         initial_capital=500,
         commission_type=strategy.commission.percent,
         commission_value=0.06,
         currency=currency.USD,
         max_lines_count=500,
         max_labels_count=500)

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// Í∑∏Î£π ?ÅÏàò
var GRP_CORE     = '?Öê ÏΩîÏñ¥ Î™®Î©ò?Ä'
var GRP_FLUX     = '?Öë ?åÎü≠??& ?§ÌÄ¥Ï¶à'
var GRP_THRESH   = '?Öí ?ÑÍ≥ÑÍ∞?
var GRP_FILTER   = '?Öì ?ÑÌÑ∞ & Íµ¨Ï°∞'
var GRP_GUARD    = '?Öî Í∞Ä??
var GRP_RISK     = '?Öï Î¶¨Ïä§??& ?¨Ïù¥Ïß?
var GRP_EXIT     = '?Öñ Ï∂úÍµ¨ Í¥ÄÎ¶?
var GRP_MISC     = '?Öó Í∏∞Ì?'
var GRP_UI       = '?Öò HUD & ?úÍ∞Å??

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?µÏã¨ ?ÖÎ†• (Python run_backtest ?åÎùºÎØ∏ÌÑ∞ Î∞òÏòÅ)
oscLen            = input.int(17, '?§Ïã§?àÏù¥??Í∏∏Ïù¥', minval=1, group=GRP_CORE, inline='OSC_LEN')
signalLen         = input.int(3, '?†Ìò∏??Í∏∏Ïù¥', minval=1, group=GRP_CORE, inline='OSC_LEN')
maTypeInput       = input.string('SMA', '?†Ìò∏???Ä??, options=['SMA', 'EMA', 'HMA'], group=GRP_CORE, inline='OSC_STYLE')
useSameLen        = input.bool(false, 'BB/KC Í∏∏Ïù¥ ?ôÏùº ?ÅÏö©', group=GRP_CORE, inline='BB_FLAG')
bbLen             = input.int(16, 'Î≥ºÎ¶∞?Ä Í∏∏Ïù¥', minval=1, group=GRP_CORE, tooltip='useSameLen ?úÏÑ±????oscLenÍ≥??ôÏùº', inline='BB_CONF')
bbMult            = input.float(2.6, 'BB Î∞∞Ïàò', minval=0.1, group=GRP_CORE, inline='BB_CONF')
kcLen             = input.int(15, 'ÏºàÌä∏??Í∏∏Ïù¥', minval=1, group=GRP_CORE, tooltip='useSameLen ?úÏÑ±????oscLenÍ≥??ôÏùº', inline='KC_CONF')
kcMult            = input.float(2.2, 'KC Î∞∞Ïàò', minval=0.1, group=GRP_CORE, inline='KC_CONF')
entryTfInput      = input.timeframe('5', 'ø£∆Æ∏Æ ≈∏¿”«¡∑π¿”', group=GRP_CORE, inline='TF_SEL')

fluxLen           = input.int(26, '?åÎü≠??Í∏∏Ïù¥', minval=1, group=GRP_FLUX, inline='FLUX_LEN')
fluxSmoothLen     = input.int(1, '?åÎü≠???§Î¨¥??, minval=1, group=GRP_FLUX, inline='FLUX_LEN')
fluxDeadzone      = input.float(15.0, '?åÎü≠???∞ÎìúÏ°?, minval=0.0, group=GRP_FLUX, inline='FLUX_LEN')
useFluxHeikin     = input.bool(true, '?åÎü≠??Heikin-Ashi', group=GRP_FLUX, inline='FLUX_MODE')
useModFlux        = input.bool(false, 'Î™®Îîî?åÏù¥???åÎü≠??, group=GRP_FLUX, inline='FLUX_MODE')

basisStyleInput   = input.string('AVG', 'Î™®Î©ò?Ä Í∏∞Ï???, options=['KC', 'AVG', 'Deluxe', 'Mod'], group=GRP_CORE, inline='OSC_STYLE')
requireCross      = input.bool(true, 'Î™®Î©ò?Ä ?¨Î°ú???ÑÏàò', group=GRP_CORE, inline='MOM_FLAG')
compatMode        = input.bool(false, 'Î™©Ìëú ?¨Ïñë Î™®Îìú', group=GRP_CORE, inline='COMPAT')
useNormClip       = input.bool(false, '?∏Î??ºÏù¥Ï¶??¥Î¶¨??, group=GRP_CORE, inline='COMPAT2')
normClipLimit     = input.float(160.0, '?¥Î¶Ω ?úÍ≥Ñ', minval=10.0, group=GRP_CORE, inline='COMPAT2')

useDynamicThresh  = input.bool(true, '?ôÏ†Å ?ÑÍ≥ÑÍ∞?, group=GRP_THRESH, inline='TH_MODE')
useSymThreshold   = input.bool(false, '?ÄÏπ?Í≥†Ï†ï ?ÑÍ≥ÑÍ∞?, group=GRP_THRESH, inline='TH_MODE')
autoThresholdScale = input.bool(true, '?ÑÍ≥ÑÍ∞??êÎèôÎ≥¥Ï†ï', group=GRP_THRESH, inline='TH_ADJ')
statThreshold     = input.float(68.0, '?ïÏ†Å Í∏∞Ï?Í∞?(TR1 ?ïÍ∑ú??Í∏∞Ï?)', minval=0.0, group=GRP_THRESH, inline='TH_STAT')
buyThreshold      = input.float(48.0, 'Îß§Ïàò Í∏∞Ï?Í∞?(TR1 ?ïÍ∑ú??Í∏∞Ï?)', minval=0.0, group=GRP_THRESH, inline='TH_BOUNDS')
sellThreshold     = input.float(68.0, 'Îß§ÎèÑ Í∏∞Ï?Í∞?(TR1 ?ïÍ∑ú??Í∏∞Ï?)', minval=0.0, group=GRP_THRESH, inline='TH_BOUNDS')
dynLen            = input.int(21, '?ôÏ†Å ?úÏ??∏Ï∞® Í∏∞Í∞Ñ', minval=1, group=GRP_THRESH, inline='TH_DYN')
dynMult           = input.float(1.1, '?ôÏ†Å ?úÏ??∏Ï∞® Î∞∞Ïàò', minval=0.1, group=GRP_THRESH, inline='TH_DYN')

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?ÑÌÑ∞ ?ÖÎ†•
useAdx            = input.bool(false, 'ADX ?ÑÌÑ∞', group=GRP_FILTER, inline='ADX_FLAG')
useAtrDiff        = input.bool(false, 'ATR Diff ?ÑÌÑ∞', group=GRP_FILTER, inline='ADX_FLAG')
adxLen            = input.int(10, 'ADX Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='ADX_CONF')
adxThresh         = input.float(15.0, 'ADX ?ÑÍ≥ÑÍ∞?, minval=0.0, group=GRP_FILTER, inline='ADX_CONF')
adxAtrTf          = input.timeframe('5', 'ADX/ATR ?Ä?ÑÌîÑ?àÏûÑ', group=GRP_FILTER, inline='ADX_TF')

useObv            = input.bool(false, 'OBV Í∏∞Ïö∏Í∏?, group=GRP_FILTER, inline='OBV_FLAG')
obvSmoothLen      = input.int(3, 'OBV EMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='OBV_FLAG')

useHtfTrend       = input.bool(false, '?ÅÏúÑÎ¥?Ï∂îÏÑ∏', group=GRP_FILTER, inline='HTF_FLAG')
htfTrendTf        = input.timeframe('240', '?ÅÏúÑÎ¥?TF', group=GRP_FILTER, inline='HTF_CONF')
htfMaLen          = input.int(20, '?ÅÏúÑÎ¥?EMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='HTF_CONF')

useHmaFilter      = input.bool(false, 'HMA ?ÑÌÑ∞', group=GRP_FILTER, inline='HMA_FLAG')
hmaLen            = input.int(20, 'HMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='HMA_FLAG')

useRangeFilter    = input.bool(false, '?àÏù∏ÏßÄ Î∞ïÏä§ ?ÑÌÑ∞', group=GRP_FILTER, inline='RANGE_FLAG')
rangeTf           = input.timeframe('5', '?àÏù∏ÏßÄ TF', group=GRP_FILTER, inline='RANGE_CONF')
rangeBars         = input.int(20, '?àÏù∏ÏßÄ Î¥âÏàò', minval=1, group=GRP_FILTER, inline='RANGE_BOX')
rangePercent      = input.float(1.0, '?àÏù∏ÏßÄ %', minval=0.0, group=GRP_FILTER, inline='RANGE_BOX')

useRegimeFilter   = input.bool(false, '?àÏßê ?ÑÌÑ∞', group=GRP_FILTER, inline='REGIME_FLAG')
ctxHtfTf          = input.timeframe('240', '?àÏßê TF', group=GRP_FILTER, inline='REGIME_TF')
ctxHtfEmaLen      = input.int(120, '?àÏßê EMA', minval=1, group=GRP_FILTER, inline='REGIME_EMA')
ctxHtfAdxLen      = input.int(14, '?àÏßê ADX', minval=1, group=GRP_FILTER, inline='REGIME_ADX')
ctxHtfAdxTh       = input.float(22.0, '?àÏßê ADX ?ÑÍ≥Ñ', minval=0.0, group=GRP_FILTER, inline='REGIME_ADX')

useDistanceGuard  = input.bool(false, '?¥Í≤© Í∞Ä??, group=GRP_FILTER, inline='DIST_FLAG')
distanceAtrLen    = input.int(21, 'ATR Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='DIST_ATR')
distanceTrendLen  = input.int(55, 'Ï∂îÏÑ∏ EMA Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='DIST_TREND')
distanceMaxAtr    = input.float(2.4, 'ÏµúÎ? ATR Î∞∞Ïàò', minval=0.1, group=GRP_FILTER, inline='DIST_TREND')

useDisparityGuard = input.bool(false, 'Disparity Index ?ÑÌÑ∞', group=GRP_FILTER, inline='DISP_FLAG')
disparityLen      = input.int(34, 'Disparity Í∏∏Ïù¥', minval=1, group=GRP_FILTER, inline='DISP_CONF')
disparityMaxPct   = input.float(6.0, 'Disparity ?úÍ≥Ñ %', minval=0.0, group=GRP_FILTER, inline='DISP_CONF')

useSqzGate        = input.bool(false, '?§ÌÄ¥Ï¶à Í≤åÏù¥??, group=GRP_FILTER, inline='SQZ_FLAG')
sqzReleaseBars    = input.int(5, '?§ÌÄ¥Ï¶à ?¥Ï†ú ?†Ï?', minval=1, group=GRP_FILTER, inline='SQZ_FLAG')

useReversal       = input.bool(false, 'Î∞òÏ†Ñ ÏßÑÏûÖ', group=GRP_FILTER, inline='REV_FLAG')
reversalDelaySec  = input.float(0.0, 'Î∞òÏ†Ñ ÏßÄ??Ï¥?', minval=0.0, group=GRP_FILTER, inline='REV_FLAG')

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// Í∞Ä??& Î¶¨Ïä§???ÖÎ†•
leverage          = input.float(28.0, '?àÎ≤ÑÎ¶¨Ï?', minval=1.0, group=GRP_RISK, inline='RISK_BASE')
commissionPct     = input.float(0.05, '?òÏàòÎ£?%', minval=0.0, group=GRP_RISK, inline='RISK_BASE')
slipTicks         = input.int(3, '?¨Î¶¨?ºÏ? ??, minval=0, group=GRP_RISK, inline='RISK_BASE2')
baseQtyPercent    = input.float(30.0, 'Í∏∞Î≥∏ ?¨Ï???%', minval=0.0, group=GRP_RISK, inline='RISK_BASE2')
usePyramiding     = input.bool(false, '?ºÎùºÎØ∏Îî© 1???àÏö©', group=GRP_RISK, inline='RISK_BASE2')
useSizingOverride = input.bool(false, 'Í≥†Í∏â ?¨Ïù¥Ïß??¨Ïö©', group=GRP_RISK, inline='SIZING_MODE')
sizingMode        = input.string('?êÎ≥∏ ÎπÑÏú®', '?¨Ïù¥Ïß?Î™®Îìú', options=['?êÎ≥∏ ÎπÑÏú®', 'Í≥†Ï†ï Í∏àÏï° (USD)', 'Í≥†Ï†ï Í≥ÑÏïΩ', 'Î¶¨Ïä§??Í∏∞Î∞ò'], group=GRP_RISK, inline='SIZING_MODE')
advancedPercent   = input.float(25.0, 'Í≥†Í∏â ÎπÑÏú® %', minval=0.0, group=GRP_RISK, inline='SIZ_ADV1')
fixedUsdAmount    = input.float(100.0, 'Í≥†Ï†ï USD', minval=0.0, group=GRP_RISK, inline='SIZ_ADV1')
fixedContractSize = input.float(1.0, 'Í≥†Ï†ï Í≥ÑÏïΩ ?òÎüâ', minval=0.0, group=GRP_RISK, inline='SIZ_ADV2')
riskSizingType    = input.string('?êÏ†à Í∏∞Î∞ò %', 'Î¶¨Ïä§???¨Ïù¥Ïß??Ä??, options=['?êÏ†à Í∏∞Î∞ò %', 'Í≥†Ï†ï Í≥ÑÏïΩ'], group=GRP_RISK, inline='RISK_SIZE')
baseRiskPct       = input.float(0.6, 'Í∏∞Î≥∏ Î¶¨Ïä§??%', minval=0.0, group=GRP_RISK, inline='RISK_SIZE_VAL')
riskContractSize  = input.float(1.0, 'Î¶¨Ïä§??Í≥†Ï†ï Í≥ÑÏïΩ', minval=0.0, group=GRP_RISK, inline='RISK_SIZE_VAL')
useWallet         = input.bool(false, '?îÎ†õ ?¨Ïö©', group=GRP_RISK, inline='WALLET_FLAG')
profitReservePct  = input.float(20.0, '?ÅÎ¶Ω ÎπÑÏú® %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='WALLET_CONF') * 0.01
applyReserveToSizing = input.bool(true, '?ÅÎ¶Ω Î∞òÏòÅ', group=GRP_RISK, inline='WALLET_CONF')
minTradableCapital = input.float(250.0, 'ÏµúÏÜå Í±∞Îûò ?êÎ≥∏', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_BASE')
useDrawdownScaling = input.bool(false, '?úÎ°ú?∞Îã§??Ï∂ïÏÜå', group=GRP_RISK, inline='DRAWDOWN_BASE')
drawdownTriggerPct = input.float(7.0, '?úÎ°ú?∞Îã§???∏Î¶¨Í±?%', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_CTRL')
drawdownRiskScale  = input.float(0.5, '?úÎ°ú?∞Îã§??Î¶¨Ïä§??Î∞∞Ïú®', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_CTRL')

usePerfAdaptiveRisk = input.bool(false, '?±Í≥º ?ÅÏùë Î¶¨Ïä§??, group=GRP_RISK, inline='PAR_FLAG')
parLookback         = input.int(6, 'PAR Î£©Î∞± Í±∞Îûò ??, minval=1, group=GRP_RISK, inline='PAR_FLAG')
parMinTrades        = input.int(3, 'PAR ÏµúÏÜå Í±∞Îûò', minval=1, group=GRP_RISK, inline='PAR_CORE')
parHotWinRate       = input.float(65.0, '???πÎ•† %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='PAR_CORE')
parColdWinRate      = input.float(35.0, 'ÏΩúÎìú ?πÎ•† %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='PAR_WIN')
parHotMult          = input.float(1.25, '??Î∞∞Ïú®', minval=0.0, group=GRP_RISK, inline='PAR_WIN')
parColdMult         = input.float(0.35, 'ÏΩúÎìú Î∞∞Ïú®', minval=0.0, group=GRP_RISK, inline='PAR_POST')
parPauseOnCold      = input.bool(true, 'ÏΩúÎìú??Ï§ëÏ?', group=GRP_RISK, inline='PAR_POST')

startYear         = input.int(2024, '?úÏûë ?∞ÎèÑ', group=GRP_MISC, inline='START_DATE')
startMonth        = input.int(1, '?úÏûë ??, group=GRP_MISC, inline='START_DATE')
startDay          = input.int(1, '?úÏûë ??, group=GRP_MISC, inline='START_DATE')
startTime         = timestamp(syminfo.timezone, startYear, startMonth, startDay, 0, 0)

allowLongEntry    = input.bool(true, 'Î°??àÏö©', group=GRP_MISC, inline='ENTRY_FLAG')
allowShortEntry   = input.bool(true, '???àÏö©', group=GRP_MISC, inline='ENTRY_FLAG')
reentryBars       = input.int(0, '?¨ÏßÑ???úÌïú Î¥âÏàò', minval=0, group=GRP_MISC, inline='ENTRY_CTRL')

debugForceLong    = input.bool(false, '?îÎ≤ÑÍ∑?Í∞ïÏ†ú Î°?, group=GRP_MISC, inline='DEBUG_FLAG')
debugForceShort   = input.bool(false, '?îÎ≤ÑÍ∑?Í∞ïÏ†ú ??, group=GRP_MISC, inline='DEBUG_FLAG')

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// Í∞Ä???ÖÎ†•
dailyLossGuard      = input.bool(false, '?ºÏùº ?êÏã§ Í∞Ä??, group=GRP_GUARD, inline='DAILY_FLAG')
dailyLossLimit      = input.float(80.0, '?ºÏùº ?êÏã§ ?úÎèÑ', group=GRP_GUARD, inline='DAILY_FLAG')
dailyProfitLock     = input.bool(false, '?ºÏùº ?¥Ïùµ ?†Í∏à', group=GRP_GUARD, inline='DAILY_PROF')
dailyProfitTarget   = input.float(120.0, '?ºÏùº ?¥Ïùµ Î™©Ìëú', group=GRP_GUARD, inline='DAILY_PROF')
weeklyProfitLock    = input.bool(false, 'Ï£ºÍ∞Ñ ?¥Ïùµ ?†Í∏à', group=GRP_GUARD, inline='WEEKLY_FLAG')
weeklyProfitTarget  = input.float(250.0, 'Ï£ºÍ∞Ñ ?¥Ïùµ Î™©Ìëú', group=GRP_GUARD, inline='WEEKLY_FLAG')
lossStreakGuard     = input.bool(false, '?∞Ìå® Í∞Ä??, group=GRP_GUARD, inline='STREAK_FLAG')
maxConsecutiveLoss  = input.int(3, 'ÏµúÎ? ?∞Ìå®', minval=0, group=GRP_GUARD, inline='STREAK_FLAG')
capitalGuard        = input.bool(false, '?êÎ≥∏ Í∞Ä??, group=GRP_GUARD, inline='CAPITAL_FLAG')
capitalGuardPct     = input.float(20.0, '?êÎ≥∏ Í∞Ä??%', minval=0.0, group=GRP_GUARD, inline='CAPITAL_FLAG')
maxDailyLosses      = input.int(0, '?ºÏùº ÏµúÎ? ?êÏã§ Í±∞Îûò', minval=0, group=GRP_GUARD, inline='LIMITS_COUNT')
maxWeeklyDD         = input.float(0.0, 'Ï£ºÍ∞Ñ ÏµúÎ? DD%', minval=0.0, group=GRP_GUARD, inline='LIMITS_DRAW')
maxGuardFires       = input.int(0, 'Í∞Ä??ÏµúÎ? Î∞úÎèô', minval=0, group=GRP_GUARD, inline='LIMITS_DRAW')
useGuardExit        = input.bool(false, '?†Ï†ú Ï≤?Ç∞ Í∞Ä??, group=GRP_GUARD, inline='PREEMPT_FLAG')
preemptTicks        = input.int(8, '?†Ï†ú ??, minval=0, group=GRP_GUARD, inline='PREEMPT_FLAG')
liqBufferPctInput   = input.float(0.0, 'Ï≤?Ç∞ Î≤ÑÌçº %', minval=0.0, group=GRP_GUARD, inline='PREEMPT_BUF')

useVolatilityGuard  = input.bool(false, 'Î≥Ä?ôÏÑ± Í∞Ä??, group=GRP_GUARD, inline='VOL_FLAG')
volatilityLookback  = input.int(50, 'ATR% Î£©Î∞±', minval=1, group=GRP_GUARD, inline='VOL_FLAG')
volatilityLowerPct  = input.float(0.15, 'ATR% ?òÌïú', minval=0.0, group=GRP_GUARD, inline='VOL_RANGE')
volatilityUpperPct  = input.float(2.5, 'ATR% ?ÅÌïú', minval=0.0, group=GRP_GUARD, inline='VOL_RANGE')

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// Ï∂úÍµ¨ ?ÖÎ†•
exitOpposite      = input.bool(true, 'Î∞òÎ? ?†Ìò∏ Ï≤?Ç∞', group=GRP_EXIT, inline='EXIT_BASE')
useMomFade        = input.bool(true, 'Î™®Î©ò?Ä ?òÏù¥??, group=GRP_EXIT, inline='EXIT_BASE')
momFadeMinAbs    = input.float(64.0, 'Î™®Î©ò?Ä ÏµúÏÜå ?àÎ?Í∞?, minval=0.0, group=GRP_EXIT, inline='FADE_FLAG2')

useStopLoss       = input.bool(false, 'Í∏∞Î≥∏ ?êÏ†à (?§Ïúô)', group=GRP_EXIT, inline='STOP_BASE')
stopLookback      = input.int(5, '?§Ïúô ?êÏ†à Î£©Î∞±', minval=1, group=GRP_EXIT, inline='STOP_BASE')

useAtrTrail       = input.bool(true, 'ATR ?∏Î†à??, group=GRP_EXIT, inline='ATRL_BASE')
atrTrailLen       = input.int(11, 'ATR ?∏Î†à??Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='ATRL_BASE')
atrTrailMult      = input.float(4.1, 'ATR ?∏Î†à??Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='ATRL_TUNE')
stopChannelType   = input.string('None', 'Ï±ÑÎÑê ?êÏ†à ?Ä??, options=['None', 'BB', 'KC'], group=GRP_EXIT, inline='CHAN_STOP')
stopChannelMult   = input.float(1.0, 'Ï±ÑÎÑê ?êÏ†à Î∞∞Ïàò', minval=0.1, group=GRP_EXIT, inline='CHAN_STOP')
useChannelStop    = stopChannelType != 'None'

// [Ï∂îÍ?] ?πÎì§Î¶¨Ïóê Ï∂úÍµ¨ ?ÖÎ†•
useChandelierExit = input.bool(false, "?πÎì§Î¶¨Ïóê ?êÏ†à", group=GRP_EXIT, inline="CHANDELIER_EXIT")
chandelierLen     = input.int(22, "?πÎì§Î¶¨Ïóê Í∏∞Í∞Ñ", minval=1, group=GRP_EXIT, inline="CHANDELIER_EXIT")
chandelierMult    = input.float(3.0, "?πÎì§Î¶¨Ïóê ATR Î∞∞Ïàò", minval=0.1, group=GRP_EXIT, inline="CHANDELIER_EXIT_MULT")

// [Ï∂îÍ?] ?åÎùºÎ≥ºÎ¶≠ SAR Ï∂úÍµ¨ ?ÖÎ†•
useSarExit        = input.bool(true, "?åÎùºÎ≥ºÎ¶≠ SAR ?êÏ†à", group=GRP_EXIT, inline="SAR_EXIT")
sarStart          = input.float(0.04, "SAR ?úÏûë", minval=0.001, group=GRP_EXIT, inline="SAR_EXIT_PARAMS")
sarIncrement      = input.float(0.025, "SAR Ï¶ùÎ∂Ñ", minval=0.001, group=GRP_EXIT, inline="SAR_EXIT_PARAMS")
sarMaximum        = input.float(0.38, "SAR ÏµúÎ?", minval=0.01, group=GRP_EXIT, inline="SAR_EXIT_PARAMS")

useBreakevenStop  = input.bool(false, 'Î∏åÎ†à?¥ÌÅ¨?¥Î∏ê', group=GRP_EXIT, inline='BREAKEVEN_BASE')
breakevenMult     = input.float(1.0, 'Î∏åÎ†à?¥ÌÅ¨?¥Î∏ê Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='BREAKEVEN_BASE')

// [?òÏ†ï] Í≥†Ï†ï ?êÏ†à Î°úÏßÅ % ?®ÏúÑÎ°?Î≥ÄÍ≤?
useFixedStop      = input.bool(true, 'Í≥†Ï†ï % ?êÏ†à ?¨Ïö©', group=GRP_EXIT, inline='FIXSTOP_FLAG')
fixedStopValueLong     = input.float(9.0, 'Î°??êÏ†à Í∞?(%)', minval=0.0, group=GRP_EXIT, inline='FIXSTOP_LONG')
fixedStopValueShort    = input.float(9.0, '???êÏ†à Í∞?(%)', minval=0.0, group=GRP_EXIT, inline='FIXSTOP_SHORT')

useAtrProfit      = input.bool(false, 'ATR ?¥Ïùµ Î™©Ìëú', group=GRP_EXIT, inline='ATR_PROFIT')
atrProfitMult     = input.float(2.0, 'ATR ?¥Ïùµ Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='ATR_PROFIT')
useDynVol         = input.bool(false, '?ôÏ†Å Î≥Ä??Î∞∞Ïú®', group=GRP_EXIT, inline='EXIT_GUARD')
useStopDistanceGuard = input.bool(false, '?êÏ†à Í±∞Î¶¨ Í∞Ä??, group=GRP_EXIT, inline='EXIT_GUARD')
maxStopAtrMult    = input.float(2.8, 'ÏµúÎ? ?êÏ†à ATRÎ∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='EXIT_GUARD_VAL')
useTimeStop       = input.bool(false, '?úÍ∞Ñ ?êÏ†à', group=GRP_EXIT, inline='HOLD_FLAG')
maxHoldBars       = input.int(45, 'ÏµúÎ? Î≥¥Ïú† Î¥?, minval=1, group=GRP_EXIT, inline='HOLD_CONF')
minHoldBarsInput  = input.int(0, 'ÏµúÏÜå Î≥¥Ïú† Î¥?, minval=0, group=GRP_EXIT, inline='HOLD_CONF')
useKasa           = input.bool(false, 'KASA RSI Ï∂úÍµ¨', group=GRP_EXIT, inline='KASA_FLAG')
kasaRsiLen        = input.int(14, 'KASA RSI Í∏∏Ïù¥', minval=1, group=GRP_EXIT, inline='KASA_FLAG')
kasaRsiOB         = input.float(72.0, 'KASA RSI OB', minval=0.0, maxval=100.0, group=GRP_EXIT, inline='KASA_RANGE')
kasaRsiOS         = input.float(28.0, 'KASA RSI OS', minval=0.0, maxval=100.0, group=GRP_EXIT, inline='KASA_RANGE')
useBeTiers        = input.bool(false, 'Î∏åÎ†à?¥ÌÅ¨?¥Î∏ê ?∞Ïñ¥', group=GRP_EXIT, inline='KASA_EXTRA')

useShock          = input.bool(false, '?ºÌÅ¨ Î™®Îìú', group=GRP_EXIT, inline='SHOCK_FLAG')
atrFastLen        = input.int(5, '?ºÌÅ¨ ATR Îπ†Î•∏??, minval=1, group=GRP_EXIT, inline='SHOCK_FLAG')
atrSlowLen        = input.int(20, '?ºÌÅ¨ ATR ?êÎ¶∞??, minval=1, group=GRP_EXIT, inline='SHOCK_CTRL')
shockMult         = input.float(2.5, '?ºÌÅ¨ Î∞∞Ïàò', minval=0.0, group=GRP_EXIT, inline='SHOCK_CTRL')
shockAction       = input.string('?êÏ†à ?Ä?¥Ìä∏??, '?ºÌÅ¨ ?âÎèô', options=['?êÏ†à ?Ä?¥Ìä∏??, 'Ï¶âÏãú Ï≤?Ç∞'], group=GRP_EXIT, inline='SHOCK_ACTION')

simpleMetricsOnly   = input.bool(false, '?¨Ìîå Î©îÌä∏Î¶?(Python)', group=GRP_MISC)

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?úÍ∞Å??& HUD ?ÖÎ†•
showHudTable           = input.bool(true, '?ÅÌÉú HUD ?úÏãú', group=GRP_UI)
hudTablePositionInput  = input.string('?∞ÏÉÅ??, '?ÅÌÉú HUD ?ÑÏπò', options=['Ï¢åÏÉÅ??, '?∞ÏÉÅ??, 'Ï¢åÌïò??, '?∞Ìïò??], group=GRP_UI)
hudTableTextSizeInput  = input.string('Î≥¥ÌÜµ', 'HUD Í∏Ä???¨Í∏∞', options=['?ëÍ≤å', 'Î≥¥ÌÜµ', '?¨Í≤å'], group=GRP_UI)
showDebugTable         = input.bool(false, 'Î™®Î©ò?Ä¬∑?åÎü≠???îÎ≤ÑÍ∑?, group=GRP_UI, inline='DBGHUD')
debugTablePositionInput = input.string('Ï¢åÌïò??, '?îÎ≤ÑÍ∑?HUD ?ÑÏπò', options=['Ï¢åÏÉÅ??, '?∞ÏÉÅ??, 'Ï¢åÌïò??, '?∞Ìïò??], group=GRP_UI, inline='DBGHUD')
showPriceHud           = input.bool(true, 'Í∞ÄÍ≤?HUD ?ºÎ≤® ?úÏãú', group=GRP_UI)
priceHudAnchorInput    = input.string('?ÑÏ™Ω', 'Í∞ÄÍ≤?HUD Í∏∞Ï?', options=['?ÑÏ™Ω', '?ÑÎûòÏ™?], group=GRP_UI)
priceHudAtrOffset      = input.float(1.0, 'Í∞ÄÍ≤?HUD ATR Î∞∞Ïàò', minval=0.0, step=0.25, group=GRP_UI)
hudBgColorInput        = input.color(color.new(color.black, 70), 'HUD Î∞∞Í≤Ω??, group=GRP_UI)
hudTextColorInput      = input.color(color.white, 'HUD Í∏Ä?êÏÉâ', group=GRP_UI)
showSqueezeHighlight   = input.bool(true, '?§ÌÄ¥Ï¶à ?òÏù¥?ºÏù¥??, group=GRP_UI)
showSignalMarkers      = input.bool(true, '?†Ìò∏ ÎßàÏª§ ?úÏãú', group=GRP_UI)
showMomentumDecorators = input.bool(true, 'Î™®Î©ò?Ä ?ÑÍ≥ÑÍ∞??úÍ∞Å??, group=GRP_UI)
showMomentumCrossMarkers = input.bool(true, 'Î™®Î©ò?Ä ?¨Î°ú??ÎßàÏª§', group=GRP_UI)
entryTfResolved    = entryTfInput == '' ? timeframe.period : entryTfInput
entryTfSeconds     = timeframe.in_seconds(entryTfResolved)
chartTfSeconds    = timeframe.in_seconds(timeframe.period)
entryUsesHtf      = entryTfSeconds > chartTfSeconds

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?¥Î? ?†Ìã∏ ?®Ïàò (Python ?¨Ìçº ?¨ÌåÖ, v5 Í∑úÍ≤©)
clamp(x, lo, hi) =>
    x < lo ? lo : x > hi ? hi : x

nzf(value, replacement) =>
    na(value) ? replacement : value

maxIgnoreNaN(a, b) =>
    na(a) ? b : na(b) ? a : math.max(a, b)

minIgnoreNaN(a, b) =>
    na(a) ? b : na(b) ? a : math.min(a, b)

trueRange() =>
    math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))

trueRangeSafe() =>
    raw = trueRange()
    nz(raw, nz(raw[1], 1e-10))

calcBasis(style, length) =>
    len = math.max(length, 1)
    hl2Local = (high + low) / 2.0
    midKC = (ta.highest(high, len) + ta.lowest(low, len)) / 2.0
    midBB = ta.sma(hl2Local, len)
    bbBasisClose = ta.sma(close, len)
    kcBasis = ta.sma(hl2Local, len)
    midline = (hl2Local + kcBasis) / 2.0
    avgLineAvg = (bbBasisClose + midKC) / 2.0
    deluxeBasis = (midKC + midBB) / 2.0
    styleLower = str.lower(style)
    switch styleLower
        'avg' => avgLineAvg
        'deluxe' => deluxeBasis
        'mod' => midline
        => midKC

calcMomentumBlock(len, sigLen, style, maType, clipEnabled, clipLimit) =>
    basis = calcBasis(style, len)
    delta = close - basis
    tr1Raw = trueRange()
    tr1SafeVal = trueRangeSafe()
    norm = tr1SafeVal != 0 ? delta / tr1SafeVal * 100.0 : 0.0
    if clipEnabled
        cap = math.max(clipLimit, 10.0)
        norm := math.min(math.max(norm, -cap), cap)
    momentum = ta.linreg(norm, len, 0)
    maTypeLower = str.lower(maType)
    signal = switch maTypeLower
        'ema' => ta.ema(momentum, sigLen)
        'hma' => ta.hma(momentum, sigLen)
        => ta.sma(momentum, sigLen)
    [momentum, signal, momentum - signal, norm, delta, tr1Raw, tr1SafeVal, basis]

calcDirectionalFlux(len, useHa) =>
    length = math.max(len, 1)
    srcH = useHa ? haHigh : high
    srcL = useHa ? haLow : low
    plusDM = math.max(srcH - nz(srcH[1]), 0)
    minusDM = math.max(nz(srcL[1]) - srcL, 0)
    plusR = ta.rma(plusDM, length)
    minusR = ta.rma(minusDM, length)
    denom = math.max(plusR + minusR, 1e-10)
    100.0 * (plusR - minusR) / denom

applyFluxDeadzone(value, deadzone) =>
    dz = math.max(deadzone, 0.0)
    if value > dz
        value - dz
    else if value < -dz
        value + dz
    else
        na

boolText(flag) =>
    flag ? '?? : '?ÑÎãà??

atrSeries(len) =>
    ta.rma(trueRange(), len)

stdSeries(src, len) =>
    ta.stdev(src, len)

disparityIndex(src, len) =>
    emaBase = ta.ema(src, len)
    diff    = ta.wma(math.abs(src - emaBase), len)
    denom   = math.abs(emaBase)
    denom == 0 or na(denom) ? 0.0 : diff / denom * 100.0

isHigherTimeframe(tf) =>
    tf != '' and timeframe.in_seconds(tf) > timeframe.in_seconds(timeframe.period)

// requestNoRepaint: (?¥Ï†Ñ Î≤ÑÏ†Ñ ?∏Ìôò?? ?ïÏ†ïÎ¥?Í∞íÏúºÎ°?Î≥¥Ï†ï
requestNoRepaint(tf, source) =>
    hasValidTf = tf != ''
    resolvedTf = hasValidTf ? tf : timeframe.period
    secSeries = request.security(syminfo.tickerid, resolvedTf, source, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
    if hasValidTf and isHigherTimeframe(resolvedTf)
        nz(secSeries[1], secSeries)
    else
        secSeries

securitySeries(tf, source) =>
    requestNoRepaint(tf, source)

resolveTablePosition(posStr) =>
    switch posStr
        'Ï¢åÏÉÅ?? => position.top_left
        'Ï¢åÌïò?? => position.bottom_left
        '?∞Ìïò?? => position.bottom_right
        => position.top_right

resolveTextSize(sizeStr) =>
    sizeStr == '?ëÍ≤å' ? size.small : sizeStr == '?¨Í≤å' ? size.large : size.normal

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// Heikin-Ashi Î°úÏª¨ Í≥ÑÏÇ∞ (security() ÎØ∏ÏÇ¨?? Í≤ΩÍ≥† Í∞êÏÜå)
var float haOpen = na
haClose = (open + high + low + close) / 4.0
haOpen  := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0
haHigh  = math.max(high, math.max(haOpen, haClose))
haLow   = math.min(low,  math.min(haOpen, haClose))

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ??[?òÏ†ï?? HTF ?àÏ†Ñ ?òÌçº: request.security ?êÎü¨Î•??¥Í≤∞?òÍ∏∞ ?ÑÌï¥ Íµ¨Ï°∞ Î≥ÄÍ≤?
// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ??[ÏµúÏ¢Ö ?òÏ†ï] HTF ?àÏ†Ñ ?òÌçº: request.securityÍ∞Ä Ï°∞Í±¥Î¨??¥Î????àÏ? ?äÎèÑÎ°?Íµ¨Ï°∞ Î≥ÄÍ≤?
f_htf(tf, indicatorType, len) =>
    // 1. ?¥Îñ§ ?∞Ïù¥?∞Î? Í≥ÑÏÇ∞?†Ï? Î®ºÏ? Í≤∞Ï†ï (??Î∂ÄÎ∂ÑÏ? Ï°∞Í±¥Î¨??àÏóê ?àÏñ¥??OK)
    float src_series = switch indicatorType
        'dmi_adx' =>
            [_, _, adx] = ta.dmi(len, len)
            adx
        'atr' => atrSeries(len)
        'ema' => ta.ema(close, len)
        'highest' => ta.highest(high, len)
        'lowest' => ta.lowest(low, len)
        'close' => close
        => na

    // 2. request.securityÎ•?Ï°∞Í±¥Î¨?Î∞ñÏóê??"Î¨¥Ï°∞Í±? ?∏Ï∂ú
    // ÎßåÏïΩ tfÍ∞Ä ÎπÑÏñ¥?àÏúºÎ©??êÎü¨Í∞Ä ?òÎ?Î°? ?ÑÏû¨ ?Ä?ÑÌîÑ?àÏûÑ?ºÎ°ú ?ÄÏ≤¥Ìï¥???àÏ†Ñ?òÍ≤å ?∏Ï∂ú
    string safe_tf = tf == '' ? timeframe.period : tf
    // lookahead=barmerge.lookahead_offÎ•??¨Ïö©?òÎ?Î°? ?ÅÏúÑ Î¥âÏù¥ ?ïÏ†ï??Í∞íÎßå Î∞òÌôò?©Îãà??
    htf_series = request.security(syminfo.tickerid, safe_tf, src_series, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

    // 3. ?¥Ï†ú Ï°∞Í±¥???∞Îùº ?¥Îñ§ Í∞íÏùÑ "Î∞òÌôò"?†Ï? Í≤∞Ï†ï
    // ?ÅÏúÑ ?Ä?ÑÌîÑ?àÏûÑ???†Ìö®???åÎßå security Í≤∞Í≥ºÍ∞íÏùÑ ?¨Ïö©?òÍ≥†, ?ÑÎãê Í≤ΩÏö∞ ?ÑÏû¨ Î¥âÏùò Í≥ÑÏÇ∞Í∞íÏùÑ ?¨Ïö©
    bool useHtf = tf != '' and isHigherTimeframe(safe_tf)

    // ?ìå ?§ÏãúÍ∞?barstate.isrealtime)?êÏÑú ?ÅÏúÑ ?Ä?ÑÌîÑ?àÏûÑ Í∞íÏ? ?ÑÏßÅ ?ïÏ†ï?òÏ? ?äÏ? Í∞íÏù¥ ?§Ïñ¥?Ä Í≤ΩÍ≥†???êÏù∏???úÎã§.
    //    ?§ÏãúÍ∞?Íµ¨Í∞Ñ?êÏÑú???¥Ï†Ñ ?ïÏ†ï Í∞?htf_series[1])???¨Ïö©?òÍ≥†, ?àÏä§?†Î¶¨/?ïÏ†ï Íµ¨Í∞Ñ?êÏÑú??ÏµúÏã† Í∞íÏùÑ ?¨Ïö©??ÏßÄ?∞ÏùÑ ÏµúÏÜå?îÌïú??
    float confirmedHtf = htf_series
    if useHtf
        float fallbackHtf = nz(htf_series[1], src_series)
        confirmedHtf := barstate.isrealtime ? fallbackHtf : htf_series

    final_series = useHtf ? confirmedHtf : src_series
    final_series

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?åÎü≠??ÏßÄ?úÎì§ (HA??Î°úÏª¨ ?úÎ¶¨Ï¶??úÏö©)
directionalFlux(useHa, len, smoothLen) =>
    srcH = useHa ? haHigh : high
    srcL = useHa ? haLow  : low
    // Directional movement without ATR normalisation.  Compute positive/negative
    // moves and smooth them using RMA.
    upMove  = math.max(srcH - nz(srcH[1]), 0)
    dnMove  = math.max(nz(srcL[1]) - srcL, 0)
    upR    = ta.rma(upMove, len)
    dnR    = ta.rma(dnMove, len)
    denom   = upR + dnR
    ratio   = denom != 0 ? (upR - dnR) / denom : 0
    // Smooth the ratio over half the length and scale to 100.
    core    = ta.rma(ratio, math.max(math.round(len / 2.0), 1)) * 100
    // Apply dead?ëzone shift of ¬±25 to compress small values towards zero.
    float shifted = 0.0
    if core > 25
        shifted := core - 25
    else if core < -25
        shifted := core + 25
    else
        shifted := 0.0
    smoothLen > 1 ? ta.sma(shifted, smoothLen) : shifted

modDirectionalFlux(useHa, len, smoothLen) =>
    srcH = useHa ? haHigh : high
    srcL = useHa ? haLow  : low
    // Modified directional flux uses plus/minus DM directly without ATR
    upMove  = math.max(srcH - nz(srcH[1]), 0)
    dnMove  = math.max(nz(srcL[1]) - srcL, 0)
    plusDM  = (upMove > dnMove and upMove > 0) ? upMove : 0
    minusDM = (dnMove > upMove and dnMove > 0) ? dnMove : 0
    plusR   = ta.rma(plusDM, len)
    minusR  = ta.rma(minusDM, len)
    denom   = plusR + minusR
    ratio   = denom != 0 ? (plusR - minusR) / denom : 0
    ta.rma(ratio, math.max(math.round(len / 2.0), 1)) * 100

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// Í∏∞Î≥∏ ?åÏÉùÍ∞?Í≥ÑÏÇ∞
bbLenEff = useSameLen ? oscLen : bbLen
kcLenEff = useSameLen ? oscLen : kcLen
tickSize = syminfo.mintick
slipValue = tickSize * slipTicks

// [?òÏ†ï] Í≥†Ï†ï % ?êÏ†à Í≥ÑÏÇ∞ ?®Ïàò
calcFixedStopPriceLong(entryPrice) =>
    useFixedStop and fixedStopValueLong > 0 ? entryPrice * (1 - fixedStopValueLong / 100.0) : na

calcFixedStopPriceShort(entryPrice) =>
    useFixedStop and fixedStopValueShort > 0 ? entryPrice * (1 + fixedStopValueShort / 100.0) : na

calcProspectiveStopLong(entryPrice, atrTrailSeries, dynFactor, swingLowForStop, channelStopVal) =>
    float stop = na
    // 1) ATR ?∏Î†à??
    if useAtrTrail and not na(atrTrailSeries)
        stop := maxIgnoreNaN(stop, entryPrice - atrTrailSeries * atrTrailMult * dynFactor)
    // 2) ?§Ïúô Î°úÏö∞
    if useStopLoss and not na(swingLowForStop) and swingLowForStop < entryPrice
        stop := maxIgnoreNaN(stop, swingLowForStop)
    // 3) Ï±ÑÎÑê ?§ÌÉë(?åÎùºÎØ∏ÌÑ∞Î°??ÑÎã¨??Í∞íÎßå ?¨Ïö©)
    if useChannelStop and not na(channelStopVal) and channelStopVal < entryPrice
        stop := maxIgnoreNaN(stop, channelStopVal)
    // 4) Í≥†Ï†ï % ?§ÌÉë
    fsLong = calcFixedStopPriceLong(entryPrice)
    if not na(fsLong)
        stop := maxIgnoreNaN(stop, fsLong)
    // 5) Í∞ÄÍ≤?Ï∫????ÑÎûòÎ°??¥Î†§Í∞ÄÏßÄ ?äÎèÑÎ°?
    if not na(stop)
        cap = entryPrice - syminfo.mintick
        if cap > syminfo.mintick
            stop := math.min(stop, cap)
        stop := math.max(stop, syminfo.mintick)
    stop

calcProspectiveStopShort(entryPrice, atrTrailSeries, dynFactor, swingHighForStop, channelStopVal) =>
    float stop = na
    // 1) ATR ?∏Î†à??
    if useAtrTrail and not na(atrTrailSeries)
        stop := minIgnoreNaN(stop, entryPrice + atrTrailSeries * atrTrailMult * dynFactor)
    // 2) ?§Ïúô ?òÏù¥
    if useStopLoss and not na(swingHighForStop) and swingHighForStop > entryPrice
        stop := minIgnoreNaN(stop, swingHighForStop)
    // 3) Ï±ÑÎÑê ?§ÌÉë(?åÎùºÎØ∏ÌÑ∞Î°??ÑÎã¨??Í∞íÎßå ?¨Ïö©)
    if useChannelStop and not na(channelStopVal) and channelStopVal > entryPrice
        stop := minIgnoreNaN(stop, channelStopVal)
    // 4) Í≥†Ï†ï % ?§ÌÉë
    fsShort = calcFixedStopPriceShort(entryPrice)
    if not na(fsShort)
        stop := minIgnoreNaN(stop, fsShort)
    // 5) Í∞ÄÍ≤?Ï∫????ÑÎ°ú ?¨ÎùºÍ∞ÄÏßÄ ?äÎèÑÎ°?
    if not na(stop)
        cap = entryPrice + syminfo.mintick
        stop := math.max(stop, cap)
    stop

atrPrimary = atrSeries(kcLenEff)
atrOsc = atrSeries(oscLen)

// [Ï∂îÍ?] ?πÎì§Î¶¨Ïóê Î∞?SAR Í≥ÑÏÇ∞
atrChandelier = atrSeries(chandelierLen)
chandelierLongExit = ta.highest(high, chandelierLen) - atrChandelier * chandelierMult
chandelierShortExit = ta.lowest(low, chandelierLen) + atrChandelier * chandelierMult
sarValue = ta.sar(sarStart, sarIncrement, sarMaximum)

hl2x = (high + low) / 2.0
highestHigh = ta.highest(high, kcLenEff)
lowestLow = ta.lowest(low, kcLenEff)
meanKc = (highestHigh + lowestLow) / 2.0
bbBasisClose = ta.sma(close, bbLenEff)
kcBasis = ta.sma(hl2x, kcLenEff)
kcRangeSeries = atrPrimary * kcMult
kcUpper = kcBasis + kcRangeSeries
kcLower = kcBasis - kcRangeSeries
kcAverage = (kcUpper + kcLower) / 2.0
midline = (hl2x + kcAverage) / 2.0

// Ï±ÑÎÑê ?§ÌÉë: ?Ä??Î™ÖÏãú ???†Ïñ∏(=), ?¥ÌõÑ ?¨Î???:=)
float channelStopLower = na
float channelStopUpper = na
if useChannelStop
    if stopChannelType == 'BB'
        bbStdStop = ta.stdev(close, bbLenEff) * stopChannelMult
        channelStopLower := bbBasisClose - bbStdStop
        channelStopUpper := bbBasisClose + bbStdStop
    else
        kcStopRange = atrPrimary * stopChannelMult
        channelStopLower := kcBasis - kcStopRange
        channelStopUpper := kcBasis + kcStopRange

avgLineAvg = (bbBasisClose + meanKc) / 2.0
bbMidHl2 = ta.sma(hl2x, bbLenEff)
avgLineDeluxe = (meanKc + bbMidHl2) / 2.0

momStyle = str.lower(basisStyleInput)
[momentum, momSignal, momHist, normSeries, deltaSeries, tr1RawSeries, tr1SafeSeries, activeBasis] =
    calcMomentumBlock(oscLen, signalLen, basisStyleInput, maTypeInput, useNormClip, normClipLimit)

crossUp = ta.crossover(momentum, momSignal)
crossDown = ta.crossunder(momentum, momSignal)

momAbs = math.abs(momentum)
barsSinceMomLeZero = ta.barssince(momentum <= 0)
barsSinceMomGeZero = ta.barssince(momentum >= 0)

fluxBaseCore = useModFlux ? modDirectionalFlux(useFluxHeikin, fluxLen, fluxSmoothLen) : calcDirectionalFlux(fluxLen, useFluxHeikin)
fluxRaw = fluxSmoothLen > 1 ? ta.sma(fluxBaseCore, fluxSmoothLen) : fluxBaseCore
fluxCut = applyFluxDeadzone(fluxRaw, fluxDeadzone)
fluxHist = fluxCut
fluxGate = nz(fluxCut, 0)








// Old momentum fade intermediate values are no longer used.  The fade logic
// now references only momentum, its signal, and bar counts since momentum
// crossed the zero line.  The calculations below are kept as placeholders
// for backward compatibility but have no effect on the simplified fade exit.
float momFadeSource = na
float momFadeBasis = na
float momFadeTr = na
float momFadeHist = na
float momFadeAbs = na

bbDev = stdSeries(close, bbLenEff) * bbMult
gateSqOn = bbDev < kcRangeSeries ? 1 : 0
gateSqPrev = gateSqOn[1] == 1
gateSqRelease = gateSqPrev and gateSqOn == 0
var int gateRelCounter = na
if gateSqRelease
    gateRelCounter := 0
else if not na(gateRelCounter)
    gateRelCounter += 1

thresholdScale = 1.0
statThresholdEff = statThreshold
buyThresholdEff = buyThreshold
sellThresholdEff = sellThreshold

var float buyThresh = na
var float sellThresh = na
if useDynamicThresh
    dynStd = ta.stdev(momentum, dynLen) * dynMult
    fallbackBase = statThresholdEff != 0 ? math.abs(statThresholdEff) : nz(ta.sma(dynStd, dynLen), 1.0)
    fallback = fallbackBase
    dynStd := na(dynStd) or dynStd == 0 ? fallback : math.abs(dynStd)
    buyThresh := -dynStd
    sellThresh := dynStd
else
    if useSymThreshold
        buyThresh := -math.abs(statThresholdEff)
        sellThresh := math.abs(statThresholdEff)
    else
        buyThresh := -math.abs(buyThresholdEff)
        sellThresh := math.abs(sellThresholdEff)

float volGuardAtrPct = na
if useVolatilityGuard
    atrVal = atrSeries(volatilityLookback)
    volGuardAtrPct := atrVal / close * 100

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ??[?òÏ†ï?? HTF ?úÎ¶¨Ï¶? ?òÏ†ï??f_htf ?®Ïàò ?∏Ï∂ú Î∞©Ïãù?ºÎ°ú Î≥ÄÍ≤?
adxHtfSeries = f_htf(adxAtrTf, 'dmi_adx', adxLen)
atrHtfSeries = f_htf(adxAtrTf, 'atr', adxLen)

float adxSeries = 0.0
float atrDiff = 0.0
if useAdx or useAtrDiff
    adxSeries := nz(adxHtfSeries)
    if useAtrDiff
        atrDiff := nz(atrHtfSeries - ta.sma(atrHtfSeries, adxLen))

var float obvAccum = 0.0
float obvSlopeVal = 0.0
if useObv
    direction = math.sign(close - close[1])
    obvAccum := nz(obvAccum[1]) + direction * nz(volume, 0)
    obvSlopeVal := ta.ema(ta.change(obvAccum), math.max(obvSmoothLen, 1))

htfMaSeries = f_htf(htfTrendTf, 'ema', htfMaLen)
htfMa = useHtfTrend ? htfMaSeries : close
htfTrendUp = not useHtfTrend or (close > htfMa)
htfTrendDown = not useHtfTrend or (close < htfMa)

hmaValue = useHmaFilter ? ta.hma(close, hmaLen) : close

rangeHighSeries = f_htf(rangeTf, 'highest', rangeBars)
rangeLowSeries  = f_htf(rangeTf, 'lowest', rangeBars)
inRangeBox = false
if useRangeFilter
    rangeHighVal = rangeHighSeries
    rangeLowVal  = rangeLowSeries
    inRangeBox   := not na(rangeHighVal) and not na(rangeLowVal) and rangeLowVal != 0 ? ((rangeHighVal - rangeLowVal) / math.abs(rangeLowVal) * 100) <= rangePercent : false

disparityPct = useDisparityGuard ? disparityIndex(close, disparityLen) : 0.0
disparityOk = not useDisparityGuard or disparityPct <= disparityMaxPct

kasaRsiVal = useKasa ? ta.rsi(close, kasaRsiLen) : 50

// ??[?òÏ†ï?? ?àÏßê ?ÑÌÑ∞???ÅÏúÑ ?Ä?ÑÌîÑ?àÏûÑ ?∏Ï∂ú Î∞©Ïãù Î≥ÄÍ≤?
ctxCloseSeries = f_htf(ctxHtfTf, 'close', 0) // Í∏∏Ïù¥??Î∂àÌïÑ?îÌïòÎØÄÎ°?0
ctxEmaSeries   = f_htf(ctxHtfTf, 'ema', ctxHtfEmaLen)
ctxAdxSeries   = f_htf(ctxHtfTf, 'dmi_adx', ctxHtfAdxLen)
regimeLongOk = true
regimeShortOk = true
if useRegimeFilter
    regimeLongOk  := not na(ctxCloseSeries) and not na(ctxEmaSeries) and not na(ctxAdxSeries) and (ctxCloseSeries > ctxEmaSeries and ctxAdxSeries > ctxHtfAdxTh)
    regimeShortOk := not na(ctxCloseSeries) and not na(ctxEmaSeries) and not na(ctxAdxSeries) and (ctxCloseSeries < ctxEmaSeries and ctxAdxSeries > ctxHtfAdxTh)

gateSqValid = not useSqzGate ? true : (not na(gateRelCounter) and gateRelCounter <= sqzReleaseBars and gateSqOn == 0)

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?ÅÌÉú Î≥Ä??Ï¥àÍ∏∞??
var bool guardFrozen = false
var int guardFiredTotal = 0
var int lossStreak = 0
var int dailyLosses = 0
var int reentryCountdown = 0
var int reversalCountdown = 0
var int lastDir = 0
var float tradableCapital = strategy.initial_capital
var float peakEquity = strategy.initial_capital
var float dailyStartCapital = strategy.initial_capital
var float dailyPeakCapital = strategy.initial_capital
var float weekStartEquity = strategy.initial_capital
var float weekPeakEquity = strategy.initial_capital
var float withdrawable = 0.0
var float lastEntryPrice = na
var float lastEntryQty = 0.0
var float baseEntryQty = 0.0
var int pyramidAdds = 0
var int lastPositionDir = 0
var float highestSinceEntry = na
var float lowestSinceEntry = na
var float fixedStopPriceLong = na
var float fixedStopPriceShort = na
var int barsHeld = 0
var float liqBufferPct = liqBufferPctInput * 0.01
var array<float> recentPnls = array.new_float()
var table statusTable = na
var table debugTable = na
var string statusTablePosCache = ''
var string debugTablePosCache = ''
var label priceHudLabel = na

// [Ï∂îÍ?] ?πÎì§Î¶¨Ïóê Trailing Stop???ÑÌïú Î≥Ä??
var float chandelierStop = na

newDay = dayofmonth != dayofmonth[1]
newWeek = weekofyear != weekofyear[1]

if barstate.isconfirmed
    profitDelta = strategy.netprofit - nz(strategy.netprofit[1])
    if useWallet and profitDelta > 0
        withdrawable += profitDelta * profitReservePct

equity = strategy.equity
effectiveEquity = useWallet and applyReserveToSizing ? equity - withdrawable : equity
tradableCapital := math.max(effectiveEquity, strategy.initial_capital * 0.01)

peakEquity := math.max(peakEquity, equity)
dailyPeakCapital := math.max(dailyPeakCapital, tradableCapital)
weekPeakEquity := math.max(weekPeakEquity, equity)

if newDay
    dailyStartCapital := tradableCapital
    dailyPeakCapital := tradableCapital
    dailyLosses := 0
    guardFrozen := false
if newWeek
    weekStartEquity := equity
    weekPeakEquity := equity

dailyPnl = tradableCapital - dailyStartCapital
weeklyPnl = equity - weekStartEquity
weeklyDD = weekPeakEquity > 0 ? (weekPeakEquity - equity) / weekPeakEquity * 100 : 0
totalWithdrawable = math.max(useWallet ? withdrawable : strategy.netprofit, 0.0)

dailyLossBreached = dailyLossGuard and dailyPnl <= -math.abs(dailyLossLimit)
dailyProfitReached = dailyProfitLock and dailyPnl >= math.abs(dailyProfitTarget)
weeklyProfitReached = weeklyProfitLock and weeklyPnl >= math.abs(weeklyProfitTarget)
lossStreakBreached = lossStreakGuard and lossStreak >= maxConsecutiveLoss
capitalBreached = capitalGuard and equity <= strategy.initial_capital * (1 - capitalGuardPct / 100.0)
weeklyDdBreached = maxWeeklyDD > 0 and weeklyDD >= maxWeeklyDD
lossCountBreached = maxDailyLosses > 0 and dailyLosses >= maxDailyLosses
guardFireLimit = maxGuardFires > 0 and guardFiredTotal >= maxGuardFires
atrPctVal = useVolatilityGuard ? nz(volGuardAtrPct, 0) : 0
volatilityOk = not useVolatilityGuard or (atrPctVal >= volatilityLowerPct and atrPctVal <= volatilityUpperPct)

performancePause = false
if usePerfAdaptiveRisk and array.size(recentPnls) >= parMinTrades
    wins = 0
    for i = 0 to array.size(recentPnls) - 1
        if array.get(recentPnls, i) > 0
            wins += 1
    winRate = array.size(recentPnls) > 0 ? wins / array.size(recentPnls) * 100 : 0
    if winRate <= parColdWinRate and parPauseOnCold
        performancePause := true

performancePauseActivated = performancePause and not nz(performancePause[1], false)

shouldFreeze = dailyLossBreached or dailyProfitReached or weeklyProfitReached or lossStreakBreached or capitalBreached or weeklyDdBreached or lossCountBreached or guardFireLimit or performancePause or tradableCapital < minTradableCapital
wasFrozen = guardFrozen
if shouldFreeze
    guardFrozen := true

guardActivated = guardFrozen and not wasFrozen
if guardActivated and strategy.position_size != 0
    lastDir := strategy.position_size > 0 ? 1 : -1
    strategy.close('?¨Ï???, comment='Guard Halt')
    guardFiredTotal += 1

alertcondition(guardActivated, title='Î¶¨Ïä§??Í∞Ä??Î∞úÎèô', message='Îß§ÏßÅ1Î∂ÑVN: Í∞Ä??Î∞úÎèô?ºÎ°ú Í±∞Îûò Ï§ëÏ?')
alertcondition(performancePauseActivated, title='?±Í≥º Í∏∞Î∞ò Ï§ëÏ?', message='Îß§ÏßÅ1Î∂ÑVN: ?±Í≥º Í∏∞Î∞ò Í±∞Îûò ?ºÏãú Ï§ëÏ?')

if useGuardExit and strategy.position_size != 0 and not guardActivated
    entryP = strategy.position_avg_price
    leveragePct = leverage > 0 ? 1.0 / leverage : 0.0
    if entryP > 0 and leveragePct > 0
        priceOffset = entryP * leveragePct
        liqPrice = strategy.position_size > 0 ? entryP - priceOffset : entryP + priceOffset
        if liqBufferPct > 0
            buffer = entryP * liqBufferPct
            liqPrice += strategy.position_size > 0 ? -buffer : buffer
        liqPrice := strategy.position_size > 0 ? math.max(liqPrice, tickSize) : liqPrice
        preemptPrice = strategy.position_size > 0 ? liqPrice + preemptTicks * tickSize : liqPrice - preemptTicks * tickSize
        hitGuard = strategy.position_size > 0 ? low <= preemptPrice : high >= preemptPrice
        if hitGuard
            lastDir := strategy.position_size > 0 ? 1 : -1
            strategy.close('?¨Ï???, comment='Guard Exit')
            guardFrozen := true
            guardFiredTotal += 1

canTrade = not guardFrozen and volatilityOk
if time < startTime
    canTrade := false

if reentryCountdown > 0 and strategy.position_size == 0
    reentryCountdown -= 1
if reversalCountdown > 0 and strategy.position_size == 0
    reversalCountdown -= 1

if barstate.islast
    if showHudTable
        hudPosition = resolveTablePosition(hudTablePositionInput)
        if statusTablePosCache != hudTablePositionInput or na(statusTable)
            if not na(statusTable)
                table.delete(statusTable)
            statusTable := table.new(hudPosition, 2, 11, border_width=1)
        statusTablePosCache := hudTablePositionInput

        // [?òÏ†ï] Î≥Ä?òÎ™Ö ?§Ì? ?òÏ†ï
        hudTextSize = resolveTextSize(hudTableTextSizeInput)
        hudHeaderSize = hudTableTextSizeInput == '?ëÍ≤å' ? size.normal : hudTableTextSizeInput == '?¨Í≤å' ? size.huge : size.large

        headerBg = color.new(hudBgColorInput, 0)
        labelBg = color.new(hudBgColorInput, 35)
        neutralBg = color.new(color.gray, 85)

        capColor = tradableCapital < minTradableCapital or guardFrozen ? color.new(color.red, 55) : color.new(color.green, 65)
        dailyColor = dailyPnl > 0 ? color.new(color.green, 60) : dailyPnl < 0 ? color.new(color.red, 55) : neutralBg
        withdrawColor = totalWithdrawable > 0 ? color.new(color.green, 60) : totalWithdrawable < 0 ? color.new(color.red, 55) : neutralBg
        weeklyColor = weeklyPnl > 0 ? color.new(color.green, 60) : weeklyPnl < 0 ? color.new(color.red, 55) : neutralBg
        lossColor = lossStreak > 0 ? color.new(color.orange, 55) : color.new(color.green, 65)
        guardColor = guardFrozen ? color.new(color.red, 55) : color.new(color.green, 60)
        volColor = volatilityOk ? color.new(color.green, 60) : color.new(color.red, 55)
        perfColor = performancePause ? color.new(color.orange, 55) : color.new(color.green, 60)
        squeezeStateText = gateSqOn == 1 ? '?ïÏ∂ï ÏßÑÌñâ' : gateSqRelease ? '?¥Ï†ú ?†Ìò∏' : '?ÄÍ∏?
        squeezeColor = gateSqOn == 1 ? color.new(color.blue, 70) : gateSqRelease ? color.new(color.purple, 65) : neutralBg
        roundedBuy = math.round(buyThresh * 100.0) / 100.0
        roundedSell = math.round(sellThresh * 100.0) / 100.0
        roundedMomentum = math.round(momentum * 100.0) / 100.0
        roundedScale = math.round(thresholdScale * 100.0) / 100.0
        thresholdInfo = 'Îß§Ïàò ' + str.tostring(roundedBuy) + ' / Îß§ÎèÑ ' + str.tostring(roundedSell) + '\nÎ™®Î©ò?Ä ' + str.tostring(roundedMomentum) + '\n?§Ï???' + str.tostring(roundedScale)

        table.cell(statusTable, 0, 0, '?ìä Îß§ÏßÅ1Î∂ÑVN ?ÅÌÉú HUD', text_color=hudTextColorInput, text_size=hudHeaderSize)
        table.cell(statusTable, 1, 0, '', text_color=hudTextColorInput)
        table.merge_cells(statusTable, 0, 0, 1, 0)
        table.cell_set_bgcolor(statusTable, 0, 0, headerBg)
        table.cell_set_bgcolor(statusTable, 1, 0, headerBg)

        table.cell(statusTable, 0, 1, 'Í±∞Îûò Í∞Ä???êÎ≥∏', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 1, labelBg)
        table.cell(statusTable, 1, 1, str.tostring(tradableCapital, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 1, capColor)

        table.cell(statusTable, 0, 2, 'Ï∂úÍ∏à Í∞Ä??Í∏àÏï°', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 2, labelBg)
        table.cell(statusTable, 1, 2, str.tostring(totalWithdrawable, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 2, withdrawColor)

        table.cell(statusTable, 0, 3, '???êÏùµ', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 3, labelBg)
        table.cell(statusTable, 1, 3, str.tostring(dailyPnl, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 3, dailyColor)

        table.cell(statusTable, 0, 4, 'Ï£ºÍ∞Ñ ?êÏùµ', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 4, labelBg)
        table.cell(statusTable, 1, 4, str.tostring(weeklyPnl, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 4, weeklyColor)

        table.cell(statusTable, 0, 5, '?∞ÏÜç ?êÏã§', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 5, labelBg)
        table.cell(statusTable, 1, 5, str.tostring(lossStreak), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 5, lossColor)

        table.cell(statusTable, 0, 6, 'Í∞Ä???ÅÌÉú', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 6, labelBg)
        table.cell(statusTable, 1, 6, boolText(guardFrozen), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 6, guardColor)

        table.cell(statusTable, 0, 7, 'Î≥Ä?ôÏÑ± Ï°∞Í±¥', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 7, labelBg)
        table.cell(statusTable, 1, 7, boolText(volatilityOk), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 7, volColor)

        table.cell(statusTable, 0, 8, '?±Í≥º Ï§ëÏ?', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 8, labelBg)
        table.cell(statusTable, 1, 8, boolText(performancePause), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 8, perfColor)

        table.cell(statusTable, 0, 9, '?§ÌÄ¥Ï¶à', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 9, labelBg)
        table.cell(statusTable, 1, 9, squeezeStateText, text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 9, squeezeColor)

        table.cell(statusTable, 0, 10, '?ÑÍ≥Ñ¬∑Î™®Î©ò?Ä', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 10, labelBg)
        table.cell(statusTable, 1, 10, thresholdInfo, text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 10, labelBg)
    else
        if not na(statusTable)
            table.delete(statusTable)
        statusTable := na
        statusTablePosCache := ''

    if showDebugTable
        debugPosition = resolveTablePosition(debugTablePositionInput)
        if debugTablePosCache != debugTablePositionInput or na(debugTable)
            if not na(debugTable)
                table.delete(debugTable)
            debugTable := table.new(debugPosition, 2, 9, border_width=1)
        debugTablePosCache := debugTablePositionInput
        debugHeaderBg = color.new(hudBgColorInput, 0)
        debugLabelBg = color.new(hudBgColorInput, 45)
        debugTextColor = hudTextColorInput
        debugTextSize = size.small
        table.cell(debugTable, 0, 0, '?ß™ Î™®Î©ò?Ä¬∑?åÎü≠???îÎ≤ÑÍ∑?, text_color=debugTextColor, text_size=size.normal)
        table.cell(debugTable, 1, 0, '', text_color=debugTextColor)
        table.merge_cells(debugTable, 0, 0, 1, 0)
        table.cell_set_bgcolor(debugTable, 0, 0, debugHeaderBg)
        table.cell_set_bgcolor(debugTable, 1, 0, debugHeaderBg)

        debugVals = array.new_string()
        array.push(debugVals, str.tostring(math.round(tr1SafeSeries * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(thresholdScale * 1000.0) / 1000.0))
        array.push(debugVals, str.tostring(math.round(momentum * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(momSignal * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round((momentum - momSignal) * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(fluxRaw * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(nz(fluxCut, 0.0) * 100.0) / 100.0))

        labels = array.from('TR1', 'Scale', 'Momentum', 'Signal', 'Hist', 'Flux Raw', 'Flux Cut')
        for idx = 0 to array.size(labels) - 1
            label = array.get(labels, idx)
            value = array.get(debugVals, idx)
            rowIndex = idx + 1
            table.cell(debugTable, 0, rowIndex, label, text_color=debugTextColor, text_size=debugTextSize)
            table.cell(debugTable, 1, rowIndex, value, text_color=debugTextColor, text_size=debugTextSize)
            table.cell_set_bgcolor(debugTable, 0, rowIndex, debugLabelBg)
            table.cell_set_bgcolor(debugTable, 1, rowIndex, debugLabelBg)
    else
        if not na(debugTable)
            table.delete(debugTable)
        debugTable := na
        debugTablePosCache := ''

if strategy.position_size != 0
    barsHeld += 1
    if strategy.position_size > 0
        highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
        lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
    else
        lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
        highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
else
    barsHeld := 0
    highestSinceEntry := na
    lowestSinceEntry := na
    chandelierStop := na // [Ï∂îÍ?] ?¨Ï????ÜÏùÑ ???πÎì§Î¶¨Ïóê ?§ÌÉë Ï¥àÍ∏∞??

if strategy.position_size == 0 or not useFixedStop
    fixedStopPriceLong := na
    fixedStopPriceShort := na

positionSize = strategy.position_size
avgPrice = strategy.position_avg_price
positionDir = positionSize > 0 ? 1 : positionSize < 0 ? -1 : 0
positionSizePrev = nz(strategy.position_size[1])

openedLongThisBar = false
openedShortThisBar = false

if useFixedStop
    openedLongThisBar := positionSize > 0 and positionSizePrev <= 0
    openedShortThisBar := positionSize < 0 and positionSizePrev >= 0
    if openedLongThisBar
        float fsLong = calcFixedStopPriceLong(avgPrice)
        if not na(fsLong)
            fixedStopPriceLong := fsLong
    if openedShortThisBar
        float fsShort = calcFixedStopPriceShort(avgPrice)
        if not na(fsShort)
            fixedStopPriceShort := fsShort
    // Ï§ëÍ∞Ñ ?úÏÑ±??ÏßÄ??
    if positionDir == 1 and na(fixedStopPriceLong)
        float fsLong = calcFixedStopPriceLong(avgPrice)
        if not na(fsLong)
            fixedStopPriceLong := fsLong
    if positionDir == -1 and na(fixedStopPriceShort)
        float fsShort = calcFixedStopPriceShort(avgPrice)
        if not na(fsShort)
            fixedStopPriceShort := fsShort

// [Ï∂îÍ?] ?πÎì§Î¶¨Ïóê ?§ÌÉë Ï¥àÍ∏∞??Î∞??∏Î†à?ºÎßÅ Î°úÏßÅ
if openedLongThisBar
    chandelierStop := chandelierLongExit
if openedShortThisBar
    chandelierStop := chandelierShortExit
    
if positionDir == 1 and useChandelierExit
    chandelierStop := math.max(nz(chandelierStop[1], chandelierLongExit), chandelierLongExit)
if positionDir == -1 and useChandelierExit
    chandelierStop := math.min(nz(chandelierStop[1], chandelierShortExit), chandelierShortExit)

longCrossOk = requireCross ? crossUp : true
shortCrossOk = requireCross ? crossDown : true
baseLongTrigger = longCrossOk and momentum < buyThresh and fluxGate > 0
baseShortTrigger = shortCrossOk and momentum > sellThresh and fluxGate < 0
baseLongSignal = debugForceLong or baseLongTrigger
baseShortSignal = debugForceShort or baseShortTrigger

longOk = true
shortOk = true
if useAdx
    longOk := longOk and adxSeries > adxThresh
    shortOk := shortOk and adxSeries > adxThresh
if useObv
    longOk := longOk and obvSlopeVal > 0
    shortOk := shortOk and obvSlopeVal < 0
if useAtrDiff
    longOk := longOk and atrDiff > 0
    shortOk := shortOk and atrDiff < 0
if useHtfTrend
    longOk := longOk and htfTrendUp
    shortOk := shortOk and htfTrendDown
if useHmaFilter
    longOk := longOk and close > hmaValue
    shortOk := shortOk and close < hmaValue
if useRangeFilter
    longOk := longOk and not inRangeBox
    shortOk := shortOk and not inRangeBox
if useDistanceGuard
    longOk := longOk and (atrSeries(distanceAtrLen) > 0) and ((math.abs(close - ta.sma(close, distanceAtrLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr) and ((math.abs(close - ta.ema(close, distanceTrendLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr)
    shortOk := shortOk and (atrSeries(distanceAtrLen) > 0) and ((math.abs(close - ta.sma(close, distanceAtrLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr) and ((math.abs(close - ta.ema(close, distanceTrendLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr)
if useDisparityGuard
    longOk := longOk and disparityOk
    shortOk := shortOk and disparityOk
longOk := longOk and regimeLongOk
shortOk := shortOk and regimeShortOk

if useSqzGate
    longOk := longOk and gateSqValid
    shortOk := shortOk and gateSqValid

enterLong = allowLongEntry and canTrade and baseLongSignal and longOk and positionDir == 0 and reentryCountdown == 0
enterShort = allowShortEntry and canTrade and baseShortSignal and shortOk and positionDir == 0 and reentryCountdown == 0

alertcondition(enterLong, title='Î°?ÏßÑÏûÖ ?†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: Î°?ÏßÑÏûÖ Ï°∞Í±¥ Ï∂©Ï°±')
alertcondition(enterShort, title='??ÏßÑÏûÖ ?†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: ??ÏßÑÏûÖ Ï°∞Í±¥ Ï∂©Ï°±')

if not barstate.isconfirmed
    enterLong := false
    enterShort := false

baseLongSignalConfirmed = barstate.isconfirmed ? baseLongSignal : false
baseShortSignalConfirmed = barstate.isconfirmed ? baseShortSignal : false

if useReversal and reversalCountdown == 0 and positionDir == 0 and lastDir != 0 and canTrade and barstate.isconfirmed
    if lastDir == 1
        enterShort := true
    else if lastDir == -1
        enterLong := true
    lastDir := 0

exitLong = false
exitShort = false
exitLongReason = ''
exitShortReason = ''

translateExitReason(reason, isLong) =>
    dirLabel = isLong ? 'Î°? : '??
    switch reason
        'opposite' => 'Î∞òÎ? ?†Ìò∏ Ï≤?Ç∞ (' + (isLong ? '???†Ìò∏ Í∞êÏ?' : 'Î°??†Ìò∏ Í∞êÏ?') + ')'
        'mom_fade' => 'Î™®Î©ò?Ä ?ΩÌôî Ï≤?Ç∞ (' + dirLabel + ')'
        'time_stop' => 'ÏµúÎ? Î≥¥Ïú† ?úÍ∞Ñ Ï¥àÍ≥º Ï≤?Ç∞ (' + dirLabel + ')'
        'kasa_exit' => 'KASA Ï°∞Í±¥ Ï∂©Ï°± Ï≤?Ç∞ (' + dirLabel + ')'
        'shock' => 'Î≥Ä?ôÏÑ± ?ºÌÅ¨ Ï≤?Ç∞ (' + dirLabel + ')'
        => 'Í∏∞Ì? Ï≤?Ç∞ (' + dirLabel + ')'

// Old fade context is deprecated; use simplified momentum fade logic instead
// barsSinceMomFadeHistLong and barsSinceMomFadeHistShort were based on momFadeHist
// which is no longer used for exit logic.

if positionDir > 0
    if exitOpposite and baseShortSignalConfirmed and barsHeld >= minHoldBarsInput
        exitLong := true
        exitLongReason := 'opposite'
    // Simplified momentum fade exit: When momentum crosses below its signal
    // after being above zero (barsSinceMomLeZero > 0) and absolute momentum
    // exceeds the minimum threshold, close the long position.
    if useMomFade and barsSinceMomLeZero > 0 and crossDown and (momFadeMinAbs <= 0 or momAbs >= momFadeMinAbs)
        exitLong := true
        exitLongReason := 'mom_fade'
    if useTimeStop and maxHoldBars > 0 and barsHeld >= maxHoldBars
        exitLong := true
        exitLongReason := 'time_stop'
    if useKasa and kasaRsiVal < kasaRsiOB and kasaRsiVal[1] >= kasaRsiOB
        exitLong := true
        exitLongReason := 'kasa_exit'
else if positionDir < 0
    if exitOpposite and baseLongSignalConfirmed and barsHeld >= minHoldBarsInput
        exitShort := true
        exitShortReason := 'opposite'
    // Simplified momentum fade exit: When momentum crosses above its signal
    // after being below zero (barsSinceMomGeZero > 0) and absolute momentum
    // exceeds the minimum threshold, close the short position.
    if useMomFade and barsSinceMomGeZero > 0 and crossUp and (momFadeMinAbs <= 0 or momAbs >= momFadeMinAbs)
        exitShort := true
        exitShortReason := 'mom_fade'
    if useTimeStop and maxHoldBars > 0 and barsHeld >= maxHoldBars
        exitShort := true
        exitShortReason := 'time_stop'
    if useKasa and kasaRsiVal > kasaRsiOS and kasaRsiVal[1] <= kasaRsiOS
        exitShort := true
        exitShortReason := 'kasa_exit'

isShock = false
if useShock
    atrFast = atrSeries(atrFastLen)
    atrSlow = ta.sma(atrFast, atrSlowLen)
    isShock := atrFast > atrSlow * shockMult
if positionDir > 0 and isShock and shockAction == 'Ï¶âÏãú Ï≤?Ç∞'
    exitLong := true
    exitLongReason := 'shock'
if positionDir < 0 and isShock and shockAction == 'Ï¶âÏãú Ï≤?Ç∞'
    exitShort := true
    exitShortReason := 'shock'

longExitReasonLabel = exitLong ? translateExitReason(exitLongReason, true) : ''
shortExitReasonLabel = exitShort ? translateExitReason(exitShortReason, false) : ''

if positionDir > 0 and exitLong
    strategy.close('?¨Ï???, comment=longExitReasonLabel)
    lastDir := 1
    reentryCountdown := reentryBars
    reversalCountdown := int(reversalDelaySec / 60.0)
if positionDir < 0 and exitShort
    strategy.close('?¨Ï???, comment=shortExitReasonLabel)
    lastDir := -1
    reentryCountdown := reentryBars
    reversalCountdown := int(reversalDelaySec / 60.0)

float atrTrailSeries = atrSeries(atrTrailLen)
float dynFactor = 1.0
if useDynVol
    dynFactor := clamp(((atrTrailSeries / close) + (ta.stdev(close, 20) * 2 / close) + (math.abs(close - ta.sma(close, 50)) / close)) / 3.0 + 1.0, 0.5, 3.0)

float swingLowForStop = ta.lowest(low, stopLookback)
float swingHighForStop = ta.highest(high, stopLookback)

float stopLong = na
float stopShort = na
float targetLong = na
float targetShort = na

// [?òÏ†ï] Î™®Îì† ?êÏ†à Î°úÏßÅ ?µÌï©
if positionDir > 0
    // 1. ATR ?∏Î†à?ºÎßÅ ?§ÌÉë
    if useAtrTrail and not na(atrTrailSeries)
        stopLong := close - atrTrailSeries * atrTrailMult * dynFactor
    // 2. ?§Ïúô Î°úÏö∞ Í∏∞Î∞ò ?§ÌÉë
    if useStopLoss
        stopLong := maxIgnoreNaN(stopLong, swingLowForStop)
    // 3. Í≥†Ï†ï % ?§ÌÉë
    if useFixedStop and not na(fixedStopPriceLong)
        stopLong := maxIgnoreNaN(stopLong, fixedStopPriceLong)
    // 4. [Ï∂îÍ?] ?πÎì§Î¶¨Ïóê ?§ÌÉë
    if useChandelierExit and not na(chandelierStop)
        stopLong := maxIgnoreNaN(stopLong, chandelierStop)
    // 5. [Ï∂îÍ?] ?åÎùºÎ≥ºÎ¶≠ SAR ?§ÌÉë
    if useSarExit
        stopLong := maxIgnoreNaN(stopLong, sarValue)
    if useChannelStop and not na(channelStopLower)
        stopLong := maxIgnoreNaN(stopLong, channelStopLower)
    // 6. Î∏åÎ†à?¥ÌÅ¨?¥Î∏ê
    if useBreakevenStop and not na(highestSinceEntry) and not na(atrTrailSeries)
        move = highestSinceEntry - avgPrice
        trigger = atrTrailSeries * breakevenMult * dynFactor
        if move >= trigger
            stopLong := maxIgnoreNaN(stopLong, avgPrice)
    if useBeTiers and not na(highestSinceEntry)
        atrSeed = atrOsc
        if atrSeed > 0 and highestSinceEntry - avgPrice >= atrSeed
            stopLong := maxIgnoreNaN(stopLong, avgPrice)
    // 7. ?¥Ïùµ ?§ÌòÑ Î™©Ìëú
    if useAtrProfit and not na(atrTrailSeries)
        targetLong := avgPrice + atrTrailSeries * atrProfitMult * dynFactor
else if positionDir < 0
    // 1. ATR ?∏Î†à?ºÎßÅ ?§ÌÉë
    if useAtrTrail and not na(atrTrailSeries)
        stopShort := close + atrTrailSeries * atrTrailMult * dynFactor
    // 2. ?§Ïúô ?òÏù¥ Í∏∞Î∞ò ?§ÌÉë
    if useStopLoss
        stopShort := minIgnoreNaN(stopShort, swingHighForStop)
    // 3. Í≥†Ï†ï % ?§ÌÉë
    if useFixedStop and not na(fixedStopPriceShort)
        stopShort := minIgnoreNaN(stopShort, fixedStopPriceShort)
    // 4. [Ï∂îÍ?] ?πÎì§Î¶¨Ïóê ?§ÌÉë
    if useChandelierExit and not na(chandelierStop)
        stopShort := minIgnoreNaN(stopShort, chandelierStop)
    // 5. [Ï∂îÍ?] ?åÎùºÎ≥ºÎ¶≠ SAR ?§ÌÉë
    if useSarExit
        stopShort := minIgnoreNaN(stopShort, sarValue)
    if useChannelStop and not na(channelStopUpper)
        stopShort := minIgnoreNaN(stopShort, channelStopUpper)
    // 6. Î∏åÎ†à?¥ÌÅ¨?¥Î∏ê
    if useBreakevenStop and not na(lowestSinceEntry) and not na(atrTrailSeries)
        move = avgPrice - lowestSinceEntry
        trigger = atrTrailSeries * breakevenMult * dynFactor
        if move >= trigger
            stopShort := minIgnoreNaN(stopShort, avgPrice)
    if useBeTiers and not na(lowestSinceEntry)
        atrSeed = atrOsc
        if atrSeed > 0 and avgPrice - lowestSinceEntry >= atrSeed
            stopShort := minIgnoreNaN(stopShort, avgPrice)
    // 7. ?¥Ïùµ ?§ÌòÑ Î™©Ìëú
    if useAtrProfit and not na(atrTrailSeries)
        targetShort := avgPrice - atrTrailSeries * atrProfitMult * dynFactor

if positionDir > 0
    if not na(stopLong) and low <= stopLong
        strategy.close('?¨Ï???, comment='?êÏ†àÍ∞Ä Ï≤?Ç∞ (Î°?')
    if not na(targetLong) and high >= targetLong
        strategy.close('?¨Ï???, comment='ATR Î™©Ìëú Ï≤?Ç∞ (Î°?')
if positionDir < 0
    if not na(stopShort) and high >= stopShort
        strategy.close('?¨Ï???, comment='?êÏ†àÍ∞Ä Ï≤?Ç∞ (??')
    if not na(targetShort) and low <= targetShort
        strategy.close('?¨Ï???, comment='ATR Î™©Ìëú Ï≤?Ç∞ (??')

if exitLong
    label.new(bar_index, high, text=longExitReasonLabel, yloc=yloc.abovebar, color=color.new(color.maroon, 70), textcolor=color.white, style=label.style_label_down, size=size.tiny)

if exitShort
    label.new(bar_index, low, text=shortExitReasonLabel, yloc=yloc.belowbar, color=color.new(color.teal, 70), textcolor=color.white, style=label.style_label_up, size=size.tiny)

// alertcondition???ÑÌïú ?úÎ¶¨Ï¶?Î≥Ä??
exitLongReasonSeries = exitLong ? longExitReasonLabel : na
exitShortReasonSeries = exitShort ? shortExitReasonLabel : na
alertcondition(exitLong, title='Î°?Ï≤?Ç∞ ?†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: Î°?Ï≤?Ç∞ ??Ï°∞Í±¥ Ï∂©Ï°±')
alertcondition(exitShort, title='??Ï≤?Ç∞ ?†Ìò∏', message='Îß§ÏßÅ1Î∂ÑVN: ??Ï≤?Ç∞ ??Ï°∞Í±¥ Ï∂©Ï°±')

calcOrderSize(price, stopDistance, riskMult) =>
    result = 0.0
    if price > 0
        effectiveScale = baseRiskPct
        if useDrawdownScaling and peakEquity > 0
            dd = (peakEquity - equity) / peakEquity * 100
            if dd > drawdownTriggerPct
                effectiveScale *= drawdownRiskScale
        if usePerfAdaptiveRisk and array.size(recentPnls) >= parMinTrades
            wins = 0
            for i = 0 to array.size(recentPnls) - 1
                if array.get(recentPnls, i) > 0
                    wins += 1
            winRate = array.size(recentPnls) > 0 ? wins / array.size(recentPnls) * 100 : 0
            if winRate >= parHotWinRate
                effectiveScale *= parHotMult
            else if winRate <= parColdWinRate
                effectiveScale *= parColdMult
        mult = math.max(riskMult, 0.0)
        if not useSizingOverride
            pctToUse = math.max(baseQtyPercent * mult * (baseRiskPct > 0 ? effectiveScale / baseRiskPct : 1.0), 0.0)
            capitalPortion = tradableCapital * pctToUse / 100.0
            result := (capitalPortion * leverage) / price
        else if sizingMode == '?êÎ≥∏ ÎπÑÏú®'
            pctToUse = math.max(advancedPercent * mult, 0.0)
            capitalPortion = tradableCapital * pctToUse / 100.0
            result := (capitalPortion * leverage) / price
        else if sizingMode == 'Í≥†Ï†ï Í∏àÏï° (USD)'
            usdToUse = math.max(fixedUsdAmount * mult, 0.0)
            result := (usdToUse * leverage) / price
        else if sizingMode == 'Í≥†Ï†ï Í≥ÑÏïΩ'
            result := math.max(fixedContractSize * mult, 0.0)
        else if sizingMode == 'Î¶¨Ïä§??Í∏∞Î∞ò'
            if riskSizingType == 'Í≥†Ï†ï Í≥ÑÏïΩ'
                result := math.max(riskContractSize * mult, 0.0)
            else if stopDistance > 0 and not na(stopDistance)
                riskPct = math.max(effectiveScale * mult, 0.0)
                riskCapital = tradableCapital * riskPct / 100.0
                result := riskCapital > 0 ? riskCapital / (stopDistance + slipValue) : 0.0
    result

if positionDir == 0
    baseEntryQty := 0.0
    pyramidAdds := 0
    if enterLong
        float entryPrice = close
        float prospectiveStop = calcProspectiveStopLong(entryPrice, atrTrailSeries, dynFactor, swingLowForStop, channelStopLower)
        float stopDist = not na(prospectiveStop) ? entryPrice - prospectiveStop : na
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        float qty = calcOrderSize(entryPrice, stopForSize, 1.0)
        if guardOk and qty > 0
            strategy.entry('?¨Ï???, strategy.long, qty=qty)
            float fsLong = calcFixedStopPriceLong(entryPrice)
            if not na(fsLong)
                fixedStopPriceLong := fsLong
            lastEntryPrice := close
            lastEntryQty := qty
            baseEntryQty := qty
            pyramidAdds := 0
            lastPositionDir := 1
            highestSinceEntry := high
            lowestSinceEntry := low
            reversalCountdown := int(reversalDelaySec / 60.0)
            reentryCountdown := reentryBars
    if enterShort
        float entryPrice = close
        float prospectiveStop = calcProspectiveStopShort(entryPrice, atrTrailSeries, dynFactor, swingHighForStop, channelStopUpper)
        float stopDist = not na(prospectiveStop) ? prospectiveStop - entryPrice : na
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        float qty = calcOrderSize(entryPrice, stopForSize, 1.0)
        if guardOk and qty > 0
            strategy.entry('?¨Ï???, strategy.short, qty=qty)
            float fsShort = calcFixedStopPriceShort(entryPrice)
            if not na(fsShort)
                fixedStopPriceShort := fsShort
            lastEntryPrice := close
            lastEntryQty := qty
            baseEntryQty := qty
            pyramidAdds := 0
            lastPositionDir := -1
            highestSinceEntry := high
            lowestSinceEntry := low
            reversalCountdown := int(reversalDelaySec / 60.0)
            reentryCountdown := reentryBars
else if usePyramiding and pyramidAdds == 0 and canTrade and reentryCountdown == 0
    if positionDir > 0 and allowLongEntry and baseLongSignal and longOk
        float addQty = baseEntryQty > 0 ? baseEntryQty : lastEntryQty
        float prospectiveStop = calcProspectiveStopLong(close, atrTrailSeries, dynFactor, swingLowForStop, channelStopLower)
        float stopDist = not na(prospectiveStop) ? close - prospectiveStop : atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        if guardOk and addQty > 0
            strategy.entry('?¨Ï???, strategy.long, qty=addQty)
            float fsLong = calcFixedStopPriceLong(close)
            if not na(fsLong)
                fixedStopPriceLong := na(fixedStopPriceLong) ? fsLong : math.max(fixedStopPriceLong, fsLong)
            pyramidAdds += 1
            lastEntryPrice := strategy.position_avg_price
            lastEntryQty := strategy.position_size
            highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
            lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
    else if positionDir < 0 and allowShortEntry and baseShortSignal and shortOk
        float addQty = baseEntryQty > 0 ? baseEntryQty : lastEntryQty
        float prospectiveStop = calcProspectiveStopShort(close, atrTrailSeries, dynFactor, swingHighForStop, channelStopUpper)
        float stopDist = not na(prospectiveStop) ? prospectiveStop - close : atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        if guardOk and addQty > 0
            strategy.entry('?¨Ï???, strategy.short, qty=addQty)
            float fsShort = calcFixedStopPriceShort(close)
            if not na(fsShort)
                fixedStopPriceShort := na(fixedStopPriceShort) ? fsShort : math.min(fixedStopPriceShort, fsShort)
            pyramidAdds += 1
            lastEntryPrice := strategy.position_avg_price
            lastEntryQty := strategy.position_size
            highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
            lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)

var int prevClosedTrades = 0
currentClosedTrades = strategy.closedtrades
if currentClosedTrades > prevClosedTrades
    for idx = prevClosedTrades to currentClosedTrades - 1
        tradeProfit = strategy.closedtrades.profit(idx)
        if tradeProfit < 0
            lossStreak += 1
            dailyLosses += 1
        else if tradeProfit > 0
            lossStreak := 0
        if usePerfAdaptiveRisk
            array.push(recentPnls, tradeProfit)
            if array.size(recentPnls) > parLookback
                array.shift(recentPnls)
    prevClosedTrades := currentClosedTrades

if positionDir == 0 and (exitLong or exitShort)
    lastDir := lastPositionDir

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// HUD Ï∂úÎ†•
hudTitle = '?ìä Îß§ÏßÅ1Î∂ÑVN HUD'
positionText = positionDir > 0 ? 'Î°?Î≥¥Ïú†' : positionDir < 0 ? '??Î≥¥Ïú†' : '?¨Ï????ÜÏùå'
guardText = guardFrozen ? 'Ï§ëÏ?' : 'Í∞Ä??
canTradeText = canTrade ? 'Í∞Ä?? : 'Ï§ëÏ?'
squeezeStateText = gateSqOn == 1 ? '?ïÏ∂ï ÏßÑÌñâ' : gateSqRelease ? '?¥Ï†ú ?†Ìò∏' : '?ÄÍ∏?
roundedBuyHud = math.round(buyThresh * 100.0) / 100.0
roundedSellHud = math.round(sellThresh * 100.0) / 100.0
roundedMomentumHud = math.round(momentum * 100.0) / 100.0
hudText = hudTitle + '\n'
hudText += '?¨Ï??? ' + positionText + ' / Í±∞Îûò?ÅÌÉú: ' + canTradeText + '\n'
hudText += '?§ÌÄ¥Ï¶à: ' + squeezeStateText + ' / Î™®Î©ò?Ä: ' + str.tostring(roundedMomentumHud) + '\n'
hudText += '?ÑÍ≥ÑÍ∞?(Îß§Ïàò/Îß§ÎèÑ): ' + str.tostring(roundedBuyHud) + ' / ' + str.tostring(roundedSellHud) + '\n'
hudText += 'Í∞Ä?? ' + guardText + ' (Î∞úÎèô ' + str.tostring(guardFiredTotal) + ') / ?∞ÏÜç?êÏã§ ' + str.tostring(lossStreak) + '\n'
hudText += 'Ï∂úÍ∏à Í∞Ä?? ' + str.tostring(totalWithdrawable, format.mintick) + ' / ?ÑÏ†Å?êÏùµ: ' + str.tostring(strategy.netprofit, format.mintick) + '\n'
hudText += '?ºÏÜê?? ' + str.tostring(dailyPnl, format.mintick) + ' / ?ºÏÜê?§Ìöü?? ' + str.tostring(dailyLosses) + '\n'
hudText += 'Í∞Ä?©ÏûêÎ≥? ' + str.tostring(tradableCapital, format.mintick) + '\n'
if not na(lastEntryPrice)
    hudText += 'ÎßàÏ?Îß?ÏßÑÏûÖÍ∞Ä: ' + str.tostring(lastEntryPrice, format.price) + ' / ?òÎüâ: ' + str.tostring(lastEntryQty) + '\n'
hudText += '?àÎ≤ÑÎ¶¨Ï?: ' + str.tostring(leverage, format.mintick) + 'Î∞?/ ?†Ï†ú?? ' + str.tostring(preemptTicks)

atrForHudBase = nz(atrOsc, atrSeries(oscLen))

if barstate.islast and showPriceHud
    atrForHud = atrForHudBase
    basePrice = priceHudAnchorInput == '?ÑÏ™Ω' ? high : low
    offsetValue = nz(atrForHud, 0) * priceHudAtrOffset
    hudY = priceHudAnchorInput == '?ÑÏ™Ω' ? basePrice + offsetValue : basePrice - offsetValue
    if na(hudY)
        hudY := basePrice
    labelSize = hudTableTextSizeInput == '?ëÍ≤å' ? size.small : hudTableTextSizeInput == '?¨Í≤å' ? size.large : size.normal
    if na(priceHudLabel)
        priceHudLabel := label.new(bar_index, hudY, hudText, xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_left, color=hudBgColorInput, textcolor=hudTextColorInput, size=labelSize)
    else
        label.set_xy(priceHudLabel, bar_index, hudY)
        label.set_text(priceHudLabel, hudText)
        label.set_color(priceHudLabel, hudBgColorInput)
        label.set_textcolor(priceHudLabel, hudTextColorInput)
        label.set_style(priceHudLabel, label.style_label_left)
        label.set_size(priceHudLabel, labelSize)
else if not barstate.islast or not showPriceHud
    if not na(priceHudLabel)
        label.delete(priceHudLabel)
    priceHudLabel := na

// ?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä?Ä
// ?úÍ∞Å???åÎ°Ø & ?òÏù¥?ºÏù¥??
momentumPlotValue = barstate.isconfirmed ? momentum : nz(momentum[1], momentum)
signalPlotValue = barstate.isconfirmed ? momSignal : nz(momSignal[1], momSignal)
buyThreshPlotValue = barstate.isconfirmed ? buyThresh : nz(buyThresh[1], buyThresh)
sellThreshPlotValue = barstate.isconfirmed ? sellThresh : nz(sellThresh[1], sellThresh)

momentumPlotSeries = plot(showMomentumDecorators ? momentumPlotValue : na, title='Momentum (?ïÏ†ï)', color=color.new(color.teal, 0), linewidth=2)
signalPlotSeries = plot(showMomentumDecorators ? signalPlotValue : na, title='Signal (?ïÏ†ï)', color=color.new(color.orange, 0), linewidth=1)
buyThreshSeries = plot(showMomentumDecorators ? buyThreshPlotValue : na, title='Buy Threshold', color=color.new(color.green, 40), linewidth=1)
sellThreshSeries = plot(showMomentumDecorators ? sellThreshPlotValue : na, title='Sell Threshold', color=color.new(color.red, 40), linewidth=1)
hline(0, 'Momentum Zero', color=color.new(color.gray, 70))

fill(momentumPlotSeries, signalPlotSeries, color=showMomentumDecorators ? color.new(color.teal, 88) : na)
fill(buyThreshSeries, sellThreshSeries, color=showMomentumDecorators ? color.new(color.purple, 92) : na)

crossMarkerEnabled = showMomentumDecorators and showMomentumCrossMarkers
crossUpMarkerValue = crossMarkerEnabled and barstate.isconfirmed and crossUp ? momentumPlotValue : na
crossDownMarkerValue = crossMarkerEnabled and barstate.isconfirmed and crossDown ? momentumPlotValue : na
plotshape(crossUpMarkerValue,   title='Î™®Î©ò?Ä ?¨Î°ú????,
     style=shape.circle, location=location.absolute,
     color=color.new(color.lime, 0), size=size.tiny, text='', textcolor=color.white)

plotshape(crossDownMarkerValue, title='Î™®Î©ò?Ä ?¨Î°ú???§Ïö¥',
     style=shape.circle, location=location.absolute,
     color=color.new(color.red, 0),  size=size.tiny, text='', textcolor=color.white)
longSignalMarker = showSignalMarkers and baseLongSignalConfirmed and longOk ? buyThreshPlotValue : na
shortSignalMarker = showSignalMarkers and baseShortSignalConfirmed and shortOk ? sellThreshPlotValue : na
plotshape(longSignalMarker, title='Î°?Ï°∞Í±¥ Ï∂©Ï°±', style=shape.triangleup, location=location.absolute, color=color.new(color.lime, 0), size=size.tiny, text='Î°?, textcolor=color.white)
plotshape(shortSignalMarker, title='??Ï°∞Í±¥ Ï∂©Ï°±', style=shape.triangledown, location=location.absolute, color=color.new(color.red, 0), size=size.tiny, text='??, textcolor=color.white)

plotshape(showSignalMarkers and openedLongThisBar, title='Î°?ÏßÑÏûÖ', location=location.belowbar, style=shape.arrowup, color=color.new(color.lime, 0), text='Î°?, textcolor=color.white, size=size.small)
plotshape(showSignalMarkers and openedShortThisBar, title='??ÏßÑÏûÖ', location=location.abovebar, style=shape.arrowdown, color=color.new(color.red, 0), text='??, textcolor=color.white, size=size.small)

sqzActiveBg = showSqueezeHighlight and gateSqOn == 1 ? color.new(color.blue, 90) : na
sqzReleaseBg = showSqueezeHighlight and gateSqRelease ? color.new(color.purple, 88) : na
bgcolor(sqzActiveBg, title='Squeeze Active BG')
bgcolor(sqzReleaseBg, title='Squeeze Release BG')
bgcolor(guardFrozen ? color.new(color.red, 90) : na, title='Guard Freeze BG')

// [Ï∂îÍ?] ?êÏ†à ?ºÏù∏ ?úÍ∞Å??
plot(strategy.position_size > 0 ? stopLong : na, "Long Stop", color=color.red, style=plot.style_linebr)
plot(strategy.position_size < 0 ? stopShort : na, "Short Stop", color=color.red, style=plot.style_linebr)















