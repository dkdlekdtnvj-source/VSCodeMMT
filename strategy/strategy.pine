//@version=5
// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║ 매직1분VN — Python 백테스트 엔진과 동등한 TradingView 최종본 (예견편향 수정) ║
// ║ 원본 Python 구현을 Pine Script v5 로 1:1 로직 이식한 버전                 ║
// ║ Author: OpenAI gpt-5-codex (for Basemodule 프로젝트)                  ║
// ╚═══════════════════════════════════════════════════════════════════════════╝
// ✨ 로직 개선 (2025-10-21): 모멘텀 및 플럭스 정규화를 Squeeze Momentum Deluxe와 동일한 로직으로 전면 수정
// ✨ 로직 추가 (2025-10-22): 'useMomFade' 로직 구현 (모멘텀 정점 후 감소/증가 시 청산)
// ✨ 로직 수정 (2025-10-23): 'useMomFade' 로직 타이밍을 barstate.isconfirmed -> entrySignalPulse 로 수정 (합성봉 타이밍 일치)
strategy('통합모멘텀 (Python 포트) - Deluxe 정규화',
         overlay=false,
         process_orders_on_close=true,
         calc_on_every_tick=false,
         pyramiding=1,
         initial_capital=500,
         commission_type=strategy.commission.percent,
         commission_value=0.05,
         currency=currency.USD,
         max_lines_count=500,
         max_labels_count=500)

// ─────────────────────────────────────────────────────────────────────────────
// 그룹 상수
var GRP_CORE    = '🅐 코어 모멘텀'
var GRP_FLUX    = '🅑 플럭스 & 스퀴즈'
var GRP_THRESH  = '🅒 임계값'
var GRP_FILTER  = '🅓 필터 & 구조'
var GRP_GUARD   = '🅔 가드'
var GRP_RISK    = '🅕 리스크 & 사이징'
var GRP_EXIT    = '🅖 출구 관리'
var GRP_MISC    = '🅗 기타'
var GRP_UI      = '🅘 HUD & 시각화'

// ─────────────────────────────────────────────────────────────────────────────
// 핵심 입력 (Python run_backtest 파라미터 반영)
oscLen          = input.int(20, '오실레이터 길이', minval=1, group=GRP_CORE, inline='OSC_LEN')
signalLen       = input.int(3, '신호선 길이', minval=1, group=GRP_CORE, inline='OSC_LEN')
maTypeInput     = input.string('SMA', '신호선 타입', options=['SMA', 'EMA', 'HMA'], group=GRP_CORE, inline='OSC_STYLE')
useSameLen      = input.bool(false, 'BB/KC 길이 동일 적용', group=GRP_CORE, inline='BB_FLAG')
bbLen           = input.int(20, '볼린저 길이', minval=1, group=GRP_CORE, tooltip='useSameLen 활성화 시 oscLen과 동일', inline='BB_CONF')
bbMult          = input.float(1.4, 'BB 배수', minval=0.1, group=GRP_CORE, inline='BB_CONF')
kcLen           = input.int(18, '켈트너 길이', minval=1, group=GRP_CORE, tooltip='useSameLen 활성화 시 oscLen과 동일', inline='KC_CONF')
kcMult          = input.float(1.0, 'KC 배수', minval=0.1, group=GRP_CORE, inline='KC_CONF')

fluxLen         = input.int(14, '플럭스 길이', minval=1, group=GRP_FLUX, inline='FLUX_LEN')
fluxSmoothLen   = input.int(1, '플럭스 스무딩', minval=1, group=GRP_FLUX, inline='FLUX_LEN')
fluxDeadzone    = input.float(25.0, '플럭스 데드존', minval=0.0, group=GRP_FLUX, inline='FLUX_LEN')
useFluxHeikin   = input.bool(true, '플럭스 Heikin-Ashi', group=GRP_FLUX, inline='FLUX_MODE')
useModFlux      = input.bool(false, '모디파이드 플럭스', group=GRP_FLUX, inline='FLUX_MODE')

basisStyleInput = input.string('Deluxe', '모멘텀 기준선', options=['KC', 'AVG', 'Deluxe', 'Mod'], group=GRP_CORE, inline='OSC_STYLE')
requireCross    = input.bool(true, '모멘텀 크로스 필수', group=GRP_CORE, inline='MOM_FLAG')
compatMode      = input.bool(true, '목표 사양 모드', group=GRP_CORE, inline='COMPAT')
useNormClip     = input.bool(false, '노멀라이즈 클리핑', group=GRP_CORE, inline='COMPAT2')
normClipLimit   = input.float(350.0, '클립 한계', minval=10.0, group=GRP_CORE, inline='COMPAT2')

useDynamicThresh  = input.bool(true, '동적 임계값', group=GRP_THRESH, inline='TH_MODE')
useSymThreshold   = input.bool(false, '대칭 고정 임계값', group=GRP_THRESH, inline='TH_MODE')
autoThresholdScale = input.bool(true, '임계값 자동보정', group=GRP_THRESH, inline='TH_ADJ')
statThreshold     = input.float(38.0, '정적 기준값 (TR1 정규화 기준)', minval=0.0, group=GRP_THRESH, inline='TH_STAT')
buyThreshold      = input.float(36.0, '매수 기준값 (TR1 정규화 기준)', minval=0.0, group=GRP_THRESH, inline='TH_BOUNDS')
sellThreshold     = input.float(36.0, '매도 기준값 (TR1 정규화 기준)', minval=0.0, group=GRP_THRESH, inline='TH_BOUNDS')
dynLen            = input.int(21, '동적 표준편차 기간', minval=1, group=GRP_THRESH, inline='TH_DYN')
dynMult           = input.float(1.1, '동적 표준편차 배수', minval=0.1, group=GRP_THRESH, inline='TH_DYN')

// ─────────────────────────────────────────────────────────────────────────────
// 필터 입력
useAdx            = input.bool(false, 'ADX 필터', group=GRP_FILTER, inline='ADX_FLAG')
useAtrDiff        = input.bool(false, 'ATR Diff 필터', group=GRP_FILTER, inline='ADX_FLAG')
adxLen            = input.int(10, 'ADX 길이', minval=1, group=GRP_FILTER, inline='ADX_CONF')
adxThresh         = input.float(15.0, 'ADX 임계값', minval=0.0, group=GRP_FILTER, inline='ADX_CONF')
adxAtrTf          = input.timeframe('5', 'ADX/ATR 타임프레임', group=GRP_FILTER, inline='ADX_TF')

useObv            = input.bool(false, 'OBV 기울기', group=GRP_FILTER, inline='OBV_FLAG')
obvSmoothLen      = input.int(3, 'OBV EMA 길이', minval=1, group=GRP_FILTER, inline='OBV_FLAG')

useHtfTrend       = input.bool(false, '상위봉 추세', group=GRP_FILTER, inline='HTF_FLAG')
htfTrendTf        = input.timeframe('240', '상위봉 TF', group=GRP_FILTER, inline='HTF_CONF')
htfMaLen          = input.int(20, '상위봉 EMA 길이', minval=1, group=GRP_FILTER, inline='HTF_CONF')

useHmaFilter      = input.bool(false, 'HMA 필터', group=GRP_FILTER, inline='HMA_FLAG')
hmaLen            = input.int(20, 'HMA 길이', minval=1, group=GRP_FILTER, inline='HMA_FLAG')

useRangeFilter    = input.bool(false, '레인지 박스 필터', group=GRP_FILTER, inline='RANGE_FLAG')
rangeTf           = input.timeframe('5', '레인지 TF', group=GRP_FILTER, inline='RANGE_CONF')
rangeBars         = input.int(20, '레인지 봉수', minval=1, group=GRP_FILTER, inline='RANGE_BOX')
rangePercent      = input.float(1.0, '레인지 %', minval=0.0, group=GRP_FILTER, inline='RANGE_BOX')

useRegimeFilter   = input.bool(false, '레짐 필터', group=GRP_FILTER, inline='REGIME_FLAG')
ctxHtfTf          = input.timeframe('240', '레짐 TF', group=GRP_FILTER, inline='REGIME_TF')
ctxHtfEmaLen      = input.int(120, '레짐 EMA', minval=1, group=GRP_FILTER, inline='REGIME_EMA')
ctxHtfAdxLen      = input.int(14, '레짐 ADX', minval=1, group=GRP_FILTER, inline='REGIME_ADX')
ctxHtfAdxTh       = input.float(22.0, '레짐 ADX 임계', minval=0.0, group=GRP_FILTER, inline='REGIME_ADX')

useDistanceGuard  = input.bool(false, '이격 가드', group=GRP_FILTER, inline='DIST_FLAG')
distanceAtrLen    = input.int(21, 'ATR 길이', minval=1, group=GRP_FILTER, inline='DIST_ATR')
distanceTrendLen  = input.int(55, '추세 EMA 길이', minval=1, group=GRP_FILTER, inline='DIST_TREND')
distanceMaxAtr    = input.float(2.4, '최대 ATR 배수', minval=0.1, group=GRP_FILTER, inline='DIST_TREND')

useDisparityGuard = input.bool(false, 'Disparity Index 필터', group=GRP_FILTER, inline='DISP_FLAG')
disparityLen      = input.int(34, 'Disparity 길이', minval=1, group=GRP_FILTER, inline='DISP_CONF')
disparityMaxPct   = input.float(6.0, 'Disparity 한계 %', minval=0.0, group=GRP_FILTER, inline='DISP_CONF')

useSqzGate        = input.bool(false, '스퀴즈 게이트', group=GRP_FILTER, inline='SQZ_FLAG')
sqzReleaseBars    = input.int(5, '스퀴즈 해제 유지', minval=1, group=GRP_FILTER, inline='SQZ_FLAG')

useReversal       = input.bool(false, '반전 진입', group=GRP_FILTER, inline='REV_FLAG')
reversalDelaySec  = input.float(0.0, '반전 지연(초)', minval=0.0, group=GRP_FILTER, inline='REV_FLAG')

// ─────────────────────────────────────────────────────────────────────────────
// 가드 & 리스크 입력
leverageInput     = input.float(10.0, '레버리지', minval=1.0, maxval=30.0, group=GRP_RISK, inline='RISK_BASE')
leverage          = math.min(leverageInput, 30.0)
commissionPct     = input.float(0.05, '수수료 %', minval=0.0, group=GRP_RISK, inline='RISK_BASE')
slipTicks         = input.int(1, '슬리피지 틱', minval=0, group=GRP_RISK, inline='RISK_BASE2')
baseQtyPercent    = input.float(30.0, '기본 포지션 %', minval=0.0, group=GRP_RISK, inline='RISK_BASE2')
usePyramiding     = input.bool(false, '피라미딩 1회 허용', group=GRP_RISK, inline='RISK_BASE2')
useSizingOverride = input.bool(false, '고급 사이징 사용', group=GRP_RISK, inline='SIZING_MODE')
sizingMode        = input.string('자본 비율', '사이징 모드', options=['자본 비율', '고정 금액 (USD)', '고정 계약', '리스크 기반'], group=GRP_RISK, inline='SIZING_MODE')
advancedPercent   = input.float(25.0, '고급 비율 %', minval=0.0, group=GRP_RISK, inline='SIZ_ADV1')
fixedUsdAmount    = input.float(100.0, '고정 USD', minval=0.0, group=GRP_RISK, inline='SIZ_ADV1')
fixedContractSize = input.float(1.0, '고정 계약 수량', minval=0.0, group=GRP_RISK, inline='SIZ_ADV2')
riskSizingType    = input.string('손절 기반 %', '리스크 사이징 타입', options=['손절 기반 %', '고정 계약'], group=GRP_RISK, inline='RISK_SIZE')
baseRiskPct       = input.float(0.6, '기본 리스크 %', minval=0.0, group=GRP_RISK, inline='RISK_SIZE_VAL')
riskContractSize  = input.float(1.0, '리스크 고정 계약', minval=0.0, group=GRP_RISK, inline='RISK_SIZE_VAL')
useWallet         = input.bool(false, '월렛 사용', group=GRP_RISK, inline='WALLET_FLAG')
profitReservePct  = input.float(20.0, '적립 비율 %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='WALLET_CONF') * 0.01
applyReserveToSizing = input.bool(true, '적립 반영', group=GRP_RISK, inline='WALLET_CONF')
minTradableCapital = input.float(150.0, '최소 거래 자본', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_BASE')
useDrawdownScaling = input.bool(false, '드로우다운 축소', group=GRP_RISK, inline='DRAWDOWN_BASE')
drawdownTriggerPct = input.float(7.0, '드로우다운 트리거 %', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_CTRL')
drawdownRiskScale  = input.float(0.5, '드로우다운 리스크 배율', minval=0.0, group=GRP_RISK, inline='DRAWDOWN_CTRL')

usePerfAdaptiveRisk = input.bool(false, '성과 적응 리스크', group=GRP_RISK, inline='PAR_FLAG')
parLookback         = input.int(6, 'PAR 룩백 거래 수', minval=1, group=GRP_RISK, inline='PAR_FLAG')
parMinTrades        = input.int(3, 'PAR 최소 거래', minval=1, group=GRP_RISK, inline='PAR_CORE')
parHotWinRate       = input.float(65.0, '핫 승률 %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='PAR_CORE')
parColdWinRate      = input.float(35.0, '콜드 승률 %', minval=0.0, maxval=100.0, group=GRP_RISK, inline='PAR_WIN')
parHotMult          = input.float(1.25, '핫 배율', minval=0.0, group=GRP_RISK, inline='PAR_WIN')
parColdMult         = input.float(0.35, '콜드 배율', minval=0.0, group=GRP_RISK, inline='PAR_POST')
parPauseOnCold      = input.bool(true, '콜드시 중지', group=GRP_RISK, inline='PAR_POST')

startYear         = input.int(2024, '시작 연도', group=GRP_MISC, inline='START_DATE')
startMonth        = input.int(1, '시작 월', group=GRP_MISC, inline='START_DATE')
startDay          = input.int(1, '시작 일', group=GRP_MISC, inline='START_DATE')
startTime         = timestamp(syminfo.timezone, startYear, startMonth, startDay, 0, 0)

allowLongEntry    = input.bool(true, '롱 허용', group=GRP_MISC, inline='ENTRY_FLAG')
allowShortEntry   = input.bool(true, '숏 허용', group=GRP_MISC, inline='ENTRY_FLAG')
useEntryComposite = input.bool(false, '엔트리 합성 사용', group=GRP_MISC, inline='ENTRY_CTRL')
entryTfSelection  = input.string('3m', '엔트리 합성 TF', options=['1m', '3m', '5m'], group=GRP_MISC, inline='ENTRY_CTRL')
entryGroupMinutes = useEntryComposite ? (entryTfSelection == '1m' ? 1 : entryTfSelection == '5m' ? 5 : 3) : 1
reentryBars       = input.int(0, '재진입 제한 봉수', minval=0, group=GRP_MISC, inline='ENTRY_CTRL')

debugForceLong    = input.bool(false, '디버그 강제 롱', group=GRP_MISC, inline='DEBUG_FLAG')
debugForceShort   = input.bool(false, '디버그 강제 숏', group=GRP_MISC, inline='DEBUG_FLAG')

// ─────────────────────────────────────────────────────────────────────────────
// 가드 입력
dailyLossGuard      = input.bool(false, '일일 손실 가드', group=GRP_GUARD, inline='DAILY_FLAG')
dailyLossLimit      = input.float(80.0, '일일 손실 한도', group=GRP_GUARD, inline='DAILY_FLAG')
dailyProfitLock     = input.bool(false, '일일 이익 잠금', group=GRP_GUARD, inline='DAILY_PROF')
dailyProfitTarget   = input.float(120.0, '일일 이익 목표', group=GRP_GUARD, inline='DAILY_PROF')
weeklyProfitLock    = input.bool(false, '주간 이익 잠금', group=GRP_GUARD, inline='WEEKLY_FLAG')
weeklyProfitTarget  = input.float(250.0, '주간 이익 목표', group=GRP_GUARD, inline='WEEKLY_FLAG')
lossStreakGuard     = input.bool(false, '연패 가드', group=GRP_GUARD, inline='STREAK_FLAG')
maxConsecutiveLoss  = input.int(3, '최대 연패', minval=0, group=GRP_GUARD, inline='STREAK_FLAG')
capitalGuard        = input.bool(false, '자본 가드', group=GRP_GUARD, inline='CAPITAL_FLAG')
capitalGuardPct     = input.float(20.0, '자본 가드 %', minval=0.0, group=GRP_GUARD, inline='CAPITAL_FLAG')
maxDailyLosses      = input.int(0, '일일 최대 손실 거래', minval=0, group=GRP_GUARD, inline='LIMITS_COUNT')
maxWeeklyDD         = input.float(0.0, '주간 최대 DD%', minval=0.0, group=GRP_GUARD, inline='LIMITS_DRAW')
maxGuardFires       = input.int(0, '가드 최대 발동', minval=0, group=GRP_GUARD, inline='LIMITS_DRAW')
useGuardExit        = input.bool(false, '선제 청산 가드', group=GRP_GUARD, inline='PREEMPT_FLAG')
preemptTicks        = input.int(8, '선제 틱', minval=0, group=GRP_GUARD, inline='PREEMPT_FLAG')
liqBufferPctInput   = input.float(0.0, '청산 버퍼 %', minval=0.0, group=GRP_GUARD, inline='PREEMPT_BUF')

useVolatilityGuard  = input.bool(false, '변동성 가드', group=GRP_GUARD, inline='VOL_FLAG')
volatilityLookback  = input.int(50, 'ATR% 룩백', minval=1, group=GRP_GUARD, inline='VOL_FLAG')
volatilityLowerPct  = input.float(0.15, 'ATR% 하한', minval=0.0, group=GRP_GUARD, inline='VOL_RANGE')
volatilityUpperPct  = input.float(2.5, 'ATR% 상한', minval=0.0, group=GRP_GUARD, inline='VOL_RANGE')

// ─────────────────────────────────────────────────────────────────────────────
// 출구 입력
exitOpposite      = input.bool(true, '반대 신호 청산', group=GRP_EXIT, inline='EXIT_BASE')
useMomFade        = input.bool(false, '모멘텀 페이드', group=GRP_EXIT, inline='EXIT_BASE')
momFadeMinAbs     = input.float(0.0, '모멘텀 최소 절대값', minval=0.0, group=GRP_EXIT, inline='FADE_FLAG2')

useStopLoss       = input.bool(false, '기본 손절 (스윙)', group=GRP_EXIT, inline='STOP_BASE')
stopLookback      = input.int(5, '스윙 손절 룩백', minval=1, group=GRP_EXIT, inline='STOP_BASE')

atrTrailLen       = 7
atrTrailMult      = 2.5
stopChannelType   = input.string('None', '채널 손절 타입', options=['None', 'BB', 'KC'], group=GRP_EXIT, inline='CHAN_STOP')
stopChannelMult   = input.float(1.0, '채널 손절 배수', minval=0.1, group=GRP_EXIT, inline='CHAN_STOP')
useChannelStop    = stopChannelType != 'None'
useBandExit       = input.bool(true, 'BB/KC 밴드 출구', group=GRP_EXIT, inline='BAND_EXIT')
bandExitMinBars   = input.int(1, '밴드 최소 보유 봉', minval=0, group=GRP_EXIT, inline='BAND_EXIT')

// [추가] 샹들리에 출구 입력
useChandelierExit = input.bool(false, "샹들리에 손절", group=GRP_EXIT, inline="CHANDELIER_EXIT")
chandelierLen     = input.int(22, "샹들리에 기간", minval=1, group=GRP_EXIT, inline="CHANDELIER_EXIT")
chandelierMult    = input.float(3.0, "샹들리에 ATR 배수", minval=0.1, group=GRP_EXIT, inline="CHANDELIER_EXIT_MULT")

// [추가] 파라볼릭 SAR 출구 입력
useSarExit        = input.bool(false, "파라볼릭 SAR 손절", group=GRP_EXIT, inline="SAR_EXIT")
sarStart          = input.float(0.02, "SAR 시작", minval=0.001, group=GRP_EXIT, inline="SAR_EXIT_PARAMS")
sarIncrement      = input.float(0.02, "SAR 증분", minval=0.001, group=GRP_EXIT, inline="SAR_EXIT_PARAMS")
sarMaximum        = input.float(0.2, "SAR 최대", minval=0.01, group=GRP_EXIT, inline="SAR_EXIT_PARAMS")

useBreakevenStop  = input.bool(false, '브레이크이븐', group=GRP_EXIT, inline='BREAKEVEN_BASE')
breakevenMult     = input.float(1.0, '브레이크이븐 배수', minval=0.0, group=GRP_EXIT, inline='BREAKEVEN_BASE')

// [수정] 고정 손절 로직 % 단위로 변경
useFixedStop      = input.bool(false, '고정 % 손절 사용', group=GRP_EXIT, inline='FIXSTOP_FLAG')
fixedStopPct      = input.float(2.0, '고정 손절 %', minval=0.0, group=GRP_EXIT, inline='FIXSTOP_LONG')

useAtrProfit      = input.bool(false, 'ATR 이익 목표', group=GRP_EXIT, inline='ATR_PROFIT')
atrProfitMult     = input.float(2.0, 'ATR 이익 배수', minval=0.0, group=GRP_EXIT, inline='ATR_PROFIT')
useDynVol         = input.bool(false, '동적 변동 배율', group=GRP_EXIT, inline='EXIT_GUARD')
useStopDistanceGuard = input.bool(false, '손절 거리 가드', group=GRP_EXIT, inline='EXIT_GUARD')
maxStopAtrMult    = input.float(2.8, '최대 손절 ATR배수', minval=0.0, group=GRP_EXIT, inline='EXIT_GUARD_VAL')
useTimeStop       = input.bool(false, '시간 손절', group=GRP_EXIT, inline='HOLD_FLAG')
maxHoldBars       = input.int(45, '최대 보유 봉', minval=1, group=GRP_EXIT, inline='HOLD_CONF')
minHoldBarsInput  = input.int(0, '최소 보유 봉', minval=0, group=GRP_EXIT, inline='HOLD_CONF')
useKasa           = input.bool(false, 'KASA RSI 출구', group=GRP_EXIT, inline='KASA_FLAG')
kasaRsiLen        = input.int(14, 'KASA RSI 길이', minval=1, group=GRP_EXIT, inline='KASA_FLAG')
kasaRsiOB         = input.float(72.0, 'KASA RSI OB', minval=0.0, maxval=100.0, group=GRP_EXIT, inline='KASA_RANGE')
kasaRsiOS         = input.float(28.0, 'KASA RSI OS', minval=0.0, maxval=100.0, group=GRP_EXIT, inline='KASA_RANGE')
useBeTiers        = input.bool(false, '브레이크이븐 티어', group=GRP_EXIT, inline='KASA_EXTRA')

useShock          = input.bool(false, '쇼크 모드', group=GRP_EXIT, inline='SHOCK_FLAG')
atrFastLen        = input.int(5, '쇼크 ATR 빠른선', minval=1, group=GRP_EXIT, inline='SHOCK_FLAG')
atrSlowLen        = input.int(20, '쇼크 ATR 느린선', minval=1, group=GRP_EXIT, inline='SHOCK_CTRL')
shockMult         = input.float(2.5, '쇼크 배수', minval=0.0, group=GRP_EXIT, inline='SHOCK_CTRL')
shockAction       = input.string('손절 타이트닝', '쇼크 행동', options=['손절 타이트닝', '즉시 청산'], group=GRP_EXIT, inline='SHOCK_ACTION')

simpleMetricsOnly   = input.bool(false, '심플 메트릭 (Python)', group=GRP_MISC)

// ─────────────────────────────────────────────────────────────────────────────
// 시각화 & HUD 입력
showHudTable            = input.bool(true, '상태 HUD 표시', group=GRP_UI)
hudTablePositionInput  = input.string('우상단', '상태 HUD 위치', options=['좌상단', '우상단', '좌하단', '우하단'], group=GRP_UI)
hudTableTextSizeInput  = input.string('보통', 'HUD 글자 크기', options=['작게', '보통', '크게'], group=GRP_UI)
showDebugTable           = input.bool(false, '모멘텀·플럭스 디버그', group=GRP_UI, inline='DBGHUD')
debugTablePositionInput = input.string('좌하단', '디버그 HUD 위치', options=['좌상단', '우상단', '좌하단', '우하단'], group=GRP_UI, inline='DBGHUD')
showPriceHud             = input.bool(true, '가격 HUD 라벨 표시', group=GRP_UI)
priceHudAnchorInput      = input.string('위쪽', '가격 HUD 기준', options=['위쪽', '아래쪽'], group=GRP_UI)
priceHudAtrOffset        = input.float(1.0, '가격 HUD ATR 배수', minval=0.0, step=0.25, group=GRP_UI)
hudBgColorInput          = input.color(color.new(color.black, 70), 'HUD 배경색', group=GRP_UI)
hudTextColorInput        = input.color(color.white, 'HUD 글자색', group=GRP_UI)
showSqueezeHighlight     = input.bool(true, '스퀴즈 하이라이트', group=GRP_UI)
showSignalMarkers        = input.bool(true, '신호 마커 표시', group=GRP_UI)
showMomentumDecorators = input.bool(true, '모멘텀 임계값 시각화', group=GRP_UI)
showMomentumCrossMarkers = input.bool(true, '모멘텀 크로스 마커', group=GRP_UI)

// ─────────────────────────────────────────────────────────────────────────────
// 내부 유틸 함수 (Python 헬퍼 포팅, v5 규격)
clamp(x, lo, hi) =>
    x < lo ? lo : x > hi ? hi : x

nzf(value, replacement) =>
    na(value) ? replacement : value

maxIgnoreNaN(a, b) =>
    na(a) ? b : na(b) ? a : math.max(a, b)

minIgnoreNaN(a, b) =>
    na(a) ? b : na(b) ? a : math.min(a, b)

trueRange() =>
    math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))

trueRangeFromSeries(srcHigh, srcLow, srcClose) =>
    prevClose = nz(srcClose[1], srcClose)
    rangeHighLow = srcHigh - srcLow
    rangeHighClose = math.abs(srcHigh - prevClose)
    rangeLowClose = math.abs(srcLow - prevClose)
    math.max(math.max(rangeHighLow, rangeHighClose), rangeLowClose)

atrFromSeries(srcHigh, srcLow, srcClose, len) =>
    ta.rma(trueRangeFromSeries(srcHigh, srcLow, srcClose), len)

calcBasisSeries(style, length, srcHigh, srcLow, srcClose) =>
    len = math.max(length, 1)
    hl2Local = (srcHigh + srcLow) / 2.0
    midKC = (ta.highest(srcHigh, len) + ta.lowest(srcLow, len)) / 2.0
    midBB = ta.sma(hl2Local, len)
    bbBasisClose = ta.sma(srcClose, len)
    kcBasis = ta.sma(hl2Local, len)
    midline = (hl2Local + kcBasis) / 2.0
    avgLineAvg = (bbBasisClose + midKC) / 2.0
    deluxeBasis = (midKC + midBB) / 2.0
    styleLower = str.lower(style)
    switch styleLower
        'avg' => avgLineAvg
        'deluxe' => deluxeBasis
        'mod' => midline
        => midKC

// ✨ Squeeze Momentum Deluxe 로직으로 수정된 모멘텀 정규화 함수
calcMomentumBlockSeries(len, sigLen, style, maType, clipEnabled, clipLimit, srcHigh, srcLow, srcClose) =>
    basis = calcBasisSeries(style, len, srcHigh, srcLow, srcClose)
    delta = srcClose - basis

    // Deluxe 방식의 정규화 분모 계산
    // 1. len 기간의 최고가/최저가로 합성 바(z)의 high/low를 정의
    syntheticHigh = ta.highest(srcHigh, len)
    syntheticLow  = ta.lowest(srcLow, len)

    // 2. 해당 합성 바의 단일 TR(True Range, atr(1))을 계산
    syntheticTR = trueRangeFromSeries(syntheticHigh, syntheticLow, srcClose)
    syntheticTR_Safe = syntheticTR > 0 ? syntheticTR : 1e-10

    // 3. (가격-기준선) / (합성 TR) * 100 으로 정규화
    norm = delta / syntheticTR_Safe * 100.0

    if clipEnabled
        cap = math.max(clipLimit, 10.0)
        norm := math.min(math.max(norm, -cap), cap)

    momentum = ta.linreg(norm, len, 0)
    maTypeLower = str.lower(maType)
    signal = switch maTypeLower
        'ema' => ta.ema(momentum, sigLen)
        'hma' => ta.hma(momentum, sigLen)
        => ta.sma(momentum, sigLen)

    [momentum, signal, momentum - signal, norm, delta, syntheticTR, syntheticTR_Safe, basis]

// ✨ Squeeze Momentum Deluxe 로직으로 수정된 플럭스 정규화 함수
directionalFlux(srcHigh, srcLow, haHighSeries, haLowSeries, haCloseSeries, srcCloseSeries, useHa, len, smoothLen) =>
    srcH = useHa ? haHighSeries : srcHigh
    srcL = useHa ? haLowSeries : srcLow
    srcC = useHa ? haCloseSeries : srcCloseSeries

    // 1. 스무딩된 ATR 계산
    atr_len = atrFromSeries(srcH, srcL, srcC, len)
    atr_safe = atr_len > 0 ? atr_len : 1e-10

    // 2. 스무딩된 DM을 ATR로 나눔
    up = ta.rma(math.max(srcH - nz(srcH[1]), 0), len) / atr_safe
    dn = ta.rma(math.max(nz(srcL[1]) - srcL, 0), len) / atr_safe

    denom = up + dn

    // 3. (up-dn)/(up+dn) 비율을 추가 스무딩하고 100을 곱함
    flux_val = denom != 0 ? ta.rma((up - dn) / denom, math.max(1, len / 2)) * 100 : 0
    flux_val

// ✨ Squeeze Momentum Deluxe 로직으로 수정된 수정 플럭스 정규화 함수
modDirectionalFlux(srcHigh, srcLow, haHighSeries, haLowSeries, haCloseSeries, srcCloseSeries, useHa, len, smoothLen) =>
    srcH = useHa ? haHighSeries : srcHigh
    srcL = useHa ? haLowSeries : srcLow
    srcC = useHa ? haCloseSeries : srcCloseSeries

    atr_len = atrFromSeries(srcH, srcL, srcC, len)
    atr_safe = atr_len > 0 ? atr_len : 1e-10

    upMove = math.max(srcH - nz(srcH[1]), 0)
    dnMove = math.max(nz(srcL[1]) - srcL, 0)

    plusDM = (upMove > dnMove and upMove > 0) ? upMove : 0
    minusDM = (dnMove > upMove and dnMove > 0) ? dnMove : 0

    up = ta.rma(plusDM, len) / atr_safe
    dn = ta.rma(minusDM, len) / atr_safe

    denom = up + dn
    flux_val = denom != 0 ? ta.rma((up - dn) / denom, math.max(1, len / 2)) * 100 : 0
    flux_val

applyFluxDeadzone(value, deadzone) =>
    dz = math.max(deadzone, 0.0)
    if value > dz
        value - dz
    else if value < -dz
        value + dz
    else
        na

boolText(flag) =>
    flag ? '예' : '아니오'

atrSeries(len) =>
    ta.rma(trueRange(), len)

stdSeries(src, len) =>
    ta.stdev(src, len)

disparityIndex(src, len) =>
    emaBase = ta.ema(src, len)
    diff    = ta.wma(math.abs(src - emaBase), len)
    denom   = math.abs(emaBase)
    denom == 0 or na(denom) ? 0.0 : diff / denom * 100.0

isHigherTimeframe(tf) =>
    tf != '' and timeframe.in_seconds(tf) > timeframe.in_seconds(timeframe.period)

requestNoRepaint(tf, source) =>
    hasValidTf = tf != ''
    resolvedTf = hasValidTf ? tf : timeframe.period
    secSeries = request.security(syminfo.tickerid, resolvedTf, source, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)
    if hasValidTf and isHigherTimeframe(resolvedTf)
        nz(secSeries[1], secSeries)
    else
        secSeries

securitySeries(tf, source) =>
    requestNoRepaint(tf, source)

resolveTablePosition(posStr) =>
    switch posStr
        '좌상단' => position.top_left
        '좌하단' => position.bottom_left
        '우하단' => position.bottom_right
        => position.top_right

resolveTextSize(sizeStr) =>
    sizeStr == '작게' ? size.small : sizeStr == '크게' ? size.large : size.normal

// ─────────────────────────────────────────────────────────────────────────────
// Heikin-Ashi 로컬 계산 (security() 미사용: 경고 감소)
var float haOpen = na
haClose = (open + high + low + close) / 4.0
haOpen  := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0
haHigh  = math.max(high, math.max(haOpen, haClose))
haLow   = math.min(low,  math.min(haOpen, haClose))

// ─────────────────────────────────────────────────────────────────────────────
// HTF 안전 래퍼
f_htf(tf, indicatorType, len) =>
    series float src_series = switch indicatorType
        'dmi_adx' =>
            [_, _, adx] = ta.dmi(len, len)
            adx
        'atr' => atrSeries(len)
        'ema' => ta.ema(close, len)
        'highest' => ta.highest(high, len)
        'lowest' => ta.lowest(low, len)
        'close' => close
        => na

    string safe_tf = tf == '' ? timeframe.period : tf
    series float htf_series = request.security(syminfo.tickerid, safe_tf, src_series, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)

    bool useHtf = tf != '' and isHigherTimeframe(safe_tf)

    series float confirmedHtf = htf_series
    if useHtf
        series float fallbackHtf = nz(htf_series[1], src_series)
        confirmedHtf := barstate.isrealtime ? fallbackHtf : htf_series

    series float final_series = useHtf ? confirmedHtf : src_series
    final_series

// ─────────────────────────────────────────────────────────────────────────────
// 엔트리용 커스텀 합성 바
chartStepSecRaw = timeframe.in_seconds(timeframe.period)
chartStepSec = chartStepSecRaw > 0 ? chartStepSecRaw : 60
bucketMs = math.max(entryGroupMinutes, 1) * chartStepSec * 1000
currBucket = math.floor(time / bucketMs)
var int activeBucket = na
var float bucketOpen = na
var float bucketHigh = na
var float bucketLow = na
var float bucketClose = na
var float bucketVolume = na
var float confirmedEntryOpen = na
var float confirmedEntryHigh = na
var float confirmedEntryLow = na
var float confirmedEntryClose = na
var float confirmedEntryVolume = na
var bool entrySeriesReady = false
entryBucketClosed = false

if useEntryComposite
    if na(activeBucket)
        activeBucket := currBucket
        bucketOpen := open
        bucketHigh := high
        bucketLow := low
        bucketClose := close
        bucketVolume := volume
    else
        if currBucket != activeBucket
            confirmedEntryOpen := bucketOpen
            confirmedEntryHigh := bucketHigh
            confirmedEntryLow := bucketLow
            confirmedEntryClose := bucketClose
            confirmedEntryVolume := bucketVolume
            entrySeriesReady := true
            entryBucketClosed := true
            activeBucket := currBucket
            bucketOpen := open
            bucketHigh := high
            bucketLow := low
            bucketClose := close
            bucketVolume := volume
        else
            bucketHigh := math.max(bucketHigh, high)
            bucketLow := math.min(bucketLow, low)
            bucketClose := close
            bucketVolume := nz(bucketVolume) + volume
else
    entrySeriesReady := true
    entryBucketClosed := barstate.isconfirmed
    confirmedEntryOpen := open
    confirmedEntryHigh := high
    confirmedEntryLow := low
    confirmedEntryClose := close
    confirmedEntryVolume := volume
    bucketOpen := open
    bucketHigh := high
    bucketLow := low
    bucketClose := close
    bucketVolume := volume

var float entryOpenSeries = na
var float entryHighSeries = na
var float entryLowSeries = na
var float entryCloseSeries = na
var float entryVolumeSeries = na
if entryBucketClosed
    entryOpenSeries := confirmedEntryOpen
    entryHighSeries := confirmedEntryHigh
    entryLowSeries := confirmedEntryLow
    entryCloseSeries := confirmedEntryClose
    entryVolumeSeries := confirmedEntryVolume

var float entryHaOpenSeries = na
var float entryHaCloseSeries = na
var float entryHaHighSeries = na
var float entryHaLowSeries = na
if entryBucketClosed
    baseMid = (confirmedEntryOpen + confirmedEntryClose) / 2.0
    prevHaOpen = nz(entryHaOpenSeries[1], baseMid)
    prevHaClose = nz(entryHaCloseSeries[1], baseMid)
    newHaClose = (confirmedEntryOpen + confirmedEntryHigh + confirmedEntryLow + confirmedEntryClose) / 4.0
    newHaOpen = (prevHaOpen + prevHaClose) / 2.0
    entryHaOpenSeries := newHaOpen
    entryHaCloseSeries := newHaClose
    entryHaHighSeries := math.max(confirmedEntryHigh, math.max(newHaOpen, newHaClose))
    entryHaLowSeries := math.min(confirmedEntryLow, math.min(newHaOpen, newHaClose))

// ─────────────────────────────────────────────────────────────────────────────
// 기본 파생값 계산
bbLenEff = useSameLen ? oscLen : bbLen
kcLenEff = useSameLen ? oscLen : kcLen
tickSize = syminfo.mintick
slipValue = tickSize * slipTicks

// [수정] 고정 % 손절 계산 함수
calcFixedStopPriceLong(entryPrice) =>
    useFixedStop and fixedStopPct > 0 ? entryPrice * (1 - fixedStopPct / 100.0) : na

calcFixedStopPriceShort(entryPrice) =>
    useFixedStop and fixedStopPct > 0 ? entryPrice * (1 + fixedStopPct / 100.0) : na

calcProspectiveStopLong(entryPrice, atrTrailSeries, dynFactor, swingLowForStop, channelStopVal) =>
    float stop = na
    if useStopLoss and not na(swingLowForStop) and swingLowForStop < entryPrice
        stop := maxIgnoreNaN(stop, swingLowForStop)
    if useChannelStop and not na(channelStopVal) and channelStopVal < entryPrice
        stop := maxIgnoreNaN(stop, channelStopVal)
    fsLong = calcFixedStopPriceLong(entryPrice)
    if not na(fsLong)
        stop := maxIgnoreNaN(stop, fsLong)
    if not na(stop)
        cap = entryPrice - syminfo.mintick
        if cap > syminfo.mintick
            stop := math.min(stop, cap)
        stop := math.max(stop, syminfo.mintick)
    stop

calcProspectiveStopShort(entryPrice, atrTrailSeries, dynFactor, swingHighForStop, channelStopVal) =>
    float stop = na
    if useStopLoss and not na(swingHighForStop) and swingHighForStop > entryPrice
        stop := minIgnoreNaN(stop, swingHighForStop)
    if useChannelStop and not na(channelStopVal) and channelStopVal > entryPrice
        stop := minIgnoreNaN(stop, channelStopVal)
    fsShort = calcFixedStopPriceShort(entryPrice)
    if not na(fsShort)
        stop := minIgnoreNaN(stop, fsShort)
    if not na(stop)
        cap = entryPrice + syminfo.mintick
        stop := math.max(stop, cap)
    stop

atrOsc = atrSeries(oscLen)

// SAR 상태 변수
var bool sarDirectionLong = true
var bool sarInitialised = false
var float sarExtremePoint = na
var float sarAcceleration = na
var float sarStateValue = na
var float sarPrevStart = na
var float sarPrevIncrement = na
var float sarPrevMaximum = na

// 샹들리에 및 SAR 계산
atrChandelier = atrSeries(chandelierLen)
chandelierLongExit = ta.highest(high, chandelierLen) - atrChandelier * chandelierMult
chandelierShortExit = ta.lowest(low, chandelierLen) + atrChandelier * chandelierMult

sarStartClamped = math.max(sarStart, 0.0)
sarIncrementClamped = math.max(sarIncrement, 0.0)
sarMaximumClamped = math.max(sarMaximum, sarStartClamped)

if barstate.isfirst or nz(sarPrevStart) != sarStart or nz(sarPrevIncrement) != sarIncrement or nz(sarPrevMaximum) != sarMaximum
    sarDirectionLong := true
    sarInitialised := false
    sarExtremePoint := na
    sarAcceleration := na
    sarStateValue := na
    sarPrevStart := sarStart
    sarPrevIncrement := sarIncrement
    sarPrevMaximum := sarMaximum

if not sarInitialised and not na(close) and not na(close[1]) and not na(high[1]) and not na(low[1])
    bool initialLong = close >= close[1]
    float baseHigh = high[1]
    float baseLow = low[1]
    sarDirectionLong := initialLong
    sarExtremePoint := initialLong ? baseHigh : baseLow
    sarStateValue := initialLong ? baseLow : baseHigh
    sarAcceleration := sarStartClamped
    sarInitialised := true

if sarInitialised
    float prevHigh = high[1]
    float prevLow = low[1]
    if not na(sarStateValue) and not na(prevHigh) and not na(prevLow)
        float prevHigh2 = bar_index > 1 and not na(high[2]) ? high[2] : prevHigh
        float prevLow2 = bar_index > 1 and not na(low[2]) ? low[2] : prevLow
        float accel = nz(sarAcceleration, sarStartClamped)
        float extreme = nz(sarExtremePoint, sarDirectionLong ? prevHigh : prevLow)
        float candidate = sarStateValue + accel * (extreme - sarStateValue)
        if sarDirectionLong
            if not na(prevLow)
                candidate := math.min(candidate, prevLow)
            if not na(prevLow2)
                candidate := math.min(candidate, prevLow2)
            if not na(high) and high > extreme
                sarExtremePoint := high
                accel := math.min(accel + sarIncrementClamped, sarMaximumClamped)
                sarAcceleration := accel
                extreme := sarExtremePoint
            if not na(low) and low < candidate
                sarDirectionLong := false
                candidate := extreme
                sarExtremePoint := low
                sarAcceleration := sarStartClamped
                if not na(prevHigh)
                    candidate := math.max(candidate, prevHigh)
                if not na(prevHigh2)
                    candidate := math.max(candidate, prevHigh2)
        else
            if not na(prevHigh)
                candidate := math.max(candidate, prevHigh)
            if not na(prevHigh2)
                candidate := math.max(candidate, prevHigh2)
            if not na(low) and low < extreme
                sarExtremePoint := low
                accel := math.min(accel + sarIncrementClamped, sarMaximumClamped)
                sarAcceleration := accel
                extreme := sarExtremePoint
            if not na(high) and high > candidate
                sarDirectionLong := true
                candidate := extreme
                sarExtremePoint := high
                sarAcceleration := sarStartClamped
                if not na(prevLow)
                    candidate := math.min(candidate, prevLow)
                if not na(prevLow2)
                    candidate := math.min(candidate, prevLow2)
        sarStateValue := candidate
    else if na(sarStateValue) and not na(low) and not na(high)
        sarStateValue := sarDirectionLong ? low : high
        sarExtremePoint := sarDirectionLong ? high : low
        sarAcceleration := sarStartClamped

sarValue = sarStateValue

entryHl2 = (entryHighSeries + entryLowSeries) / 2.0
highestHighEntry = ta.highest(entryHighSeries, kcLenEff)
lowestLowEntry = ta.lowest(entryLowSeries, kcLenEff)
meanKc = (highestHighEntry + lowestLowEntry) / 2.0
bbBasisClose = ta.sma(entryCloseSeries, bbLenEff)
kcBasis = ta.sma(entryHl2, kcLenEff)
atrPrimary = atrFromSeries(entryHighSeries, entryLowSeries, entryCloseSeries, kcLenEff)
kcRangeSeries = atrPrimary * kcMult
kcUpper = kcBasis + kcRangeSeries
kcLower = kcBasis - kcRangeSeries
kcAverage = (kcUpper + kcLower) / 2.0
midline = (entryHl2 + kcAverage) / 2.0

float channelStopLower = na
float channelStopUpper = na
if useChannelStop
    if stopChannelType == 'BB'
        bbStdStop = stdSeries(entryCloseSeries, bbLenEff) * stopChannelMult
        channelStopLower := bbBasisClose - bbStdStop
        channelStopUpper := bbBasisClose + bbStdStop
    else
        kcStopRange = atrPrimary * stopChannelMult
        channelStopLower := kcBasis - kcStopRange
        channelStopUpper := kcBasis + kcStopRange

avgLineAvg = (bbBasisClose + meanKc) / 2.0
bbMidHl2 = ta.sma(entryHl2, bbLenEff)
avgLineDeluxe = (meanKc + bbMidHl2) / 2.0

momStyle = str.lower(basisStyleInput)
[momentum, momSignal, momHist, normSeries, deltaSeries, syntheticTR, syntheticTR_Safe, activeBasis] =
     calcMomentumBlockSeries(oscLen, signalLen, basisStyleInput, maTypeInput, useNormClip, normClipLimit,
       entryHighSeries, entryLowSeries, entryCloseSeries)

crossUp = ta.crossover(momentum, momSignal)
crossDown = ta.crossunder(momentum, momSignal)

momAbs = math.abs(momentum)
barsSinceMomLeZero = ta.barssince(momentum <= 0)
barsSinceMomGeZero = ta.barssince(momentum >= 0)

fluxBaseCore = useModFlux
     ? modDirectionalFlux(entryHighSeries, entryLowSeries, entryHaHighSeries, entryHaLowSeries, entryHaCloseSeries, entryCloseSeries, useFluxHeikin, fluxLen, fluxSmoothLen)
     : directionalFlux(entryHighSeries, entryLowSeries, entryHaHighSeries, entryHaLowSeries, entryHaCloseSeries, entryCloseSeries, useFluxHeikin, fluxLen, fluxSmoothLen)
fluxRaw = fluxSmoothLen > 1 ? ta.sma(fluxBaseCore, fluxSmoothLen) : fluxBaseCore
fluxCut = applyFluxDeadzone(fluxRaw, fluxDeadzone)
fluxHist = fluxCut
fluxGate = nz(fluxCut, 0)

bbDev = stdSeries(entryCloseSeries, bbLenEff) * bbMult
bbUpper = bbBasisClose + bbDev
bbLower = bbBasisClose - bbDev
gateSqOn = bbDev < kcRangeSeries ? 1 : 0
gateSqPrev = gateSqOn[1] == 1
gateSqRelease = gateSqPrev and gateSqOn == 0
var int gateRelCounter = na
if gateSqRelease
    gateRelCounter := 0
else if not na(gateRelCounter)
    gateRelCounter += 1

thresholdScale = 1.0
statThresholdEff = statThreshold
buyThresholdEff = buyThreshold
sellThresholdEff = sellThreshold

var float buyThresh = na
var float sellThresh = na
if useDynamicThresh
    dynStd = ta.stdev(momentum, dynLen) * dynMult
    fallbackBase = statThresholdEff != 0 ? math.abs(statThresholdEff) : nz(ta.sma(dynStd, dynLen), 1.0)
    fallback = fallbackBase
    dynStd := na(dynStd) or dynStd == 0 ? fallback : math.abs(dynStd)
    buyThresh := -dynStd
    sellThresh := dynStd
else
    if useSymThreshold
        buyThresh := -math.abs(statThresholdEff)
        sellThresh := math.abs(statThresholdEff)
    else
        buyThresh := -math.abs(buyThresholdEff)
        sellThresh := math.abs(sellThresholdEff)

float volGuardAtrPct = na
if useVolatilityGuard
    atrVal = atrFromSeries(entryHighSeries, entryLowSeries, entryCloseSeries, volatilityLookback)
    volGuardAtrPct := atrVal / entryCloseSeries * 100

adxHtfSeries = f_htf(adxAtrTf, 'dmi_adx', adxLen)
atrHtfSeries = f_htf(adxAtrTf, 'atr', adxLen)

float adxSeries = 0.0
float atrDiff = 0.0
if useAdx or useAtrDiff
    adxSeries := nz(adxHtfSeries)
    if useAtrDiff
        atrDiff := nz(atrHtfSeries - ta.sma(atrHtfSeries, adxLen))

var float obvAccum = 0.0
float obvSlopeVal = 0.0
if useObv
    priorClose = nz(entryCloseSeries[1], entryCloseSeries)
    direction = math.sign(entryCloseSeries - priorClose)
    obvAccum := nz(obvAccum[1]) + direction * nz(entryVolumeSeries, 0)
    obvSlopeVal := ta.ema(ta.change(obvAccum), math.max(obvSmoothLen, 1))

htfMaSeries = f_htf(htfTrendTf, 'ema', htfMaLen)
htfMa = useHtfTrend ? htfMaSeries : entryCloseSeries
htfTrendUp = not useHtfTrend or (not na(entryCloseSeries) and not na(htfMa) and entryCloseSeries > htfMa)
htfTrendDown = not useHtfTrend or (not na(entryCloseSeries) and not na(htfMa) and entryCloseSeries < htfMa)

hmaValue = useHmaFilter ? ta.hma(entryCloseSeries, hmaLen) : entryCloseSeries

rangeHighSeries = f_htf(rangeTf, 'highest', rangeBars)
rangeLowSeries  = f_htf(rangeTf, 'lowest', rangeBars)
inRangeBox = false
if useRangeFilter
    rangeHighVal = rangeHighSeries
    rangeLowVal  = rangeLowSeries
    inRangeBox   := not na(rangeHighVal) and not na(rangeLowVal) and rangeLowVal != 0 ? ((rangeHighVal - rangeLowVal) / math.abs(rangeLowVal) * 100) <= rangePercent : false

disparityPct = useDisparityGuard ? disparityIndex(entryCloseSeries, disparityLen) : 0.0
disparityOk = not useDisparityGuard or disparityPct <= disparityMaxPct

kasaRsiVal = useKasa ? ta.rsi(entryCloseSeries, kasaRsiLen) : 50

ctxCloseSeries = f_htf(ctxHtfTf, 'close', 0)
ctxEmaSeries   = f_htf(ctxHtfTf, 'ema', ctxHtfEmaLen)
ctxAdxSeries   = f_htf(ctxHtfTf, 'dmi_adx', ctxHtfAdxLen)
regimeLongOk = true
regimeShortOk = true
if useRegimeFilter
    regimeLongOk  := not na(ctxCloseSeries) and not na(ctxEmaSeries) and not na(ctxAdxSeries) and (ctxCloseSeries > ctxEmaSeries and ctxAdxSeries > ctxHtfAdxTh)
    regimeShortOk := not na(ctxCloseSeries) and not na(ctxEmaSeries) and not na(ctxAdxSeries) and (ctxCloseSeries < ctxEmaSeries and ctxAdxSeries > ctxHtfAdxTh)

gateSqValid = not useSqzGate ? true : (not na(gateRelCounter) and gateRelCounter <= sqzReleaseBars and gateSqOn == 0)

// ─────────────────────────────────────────────────────────────────────────────
// 상태 변수 초기화
var bool guardFrozen = false
var bool ruinHit = false
var int guardFiredTotal = 0
var int lossStreak = 0
var int dailyLosses = 0
var int reentryCountdown = 0
var int reversalCountdown = 0
var int lastDir = 0
var float tradableCapital = strategy.initial_capital
var float peakEquity = strategy.initial_capital
var float dailyStartCapital = strategy.initial_capital
var float dailyPeakCapital = strategy.initial_capital
var float weekStartEquity = strategy.initial_capital
var float weekPeakEquity = strategy.initial_capital
var float withdrawable = 0.0
var float lastEntryPrice = na
var float lastEntryQty = 0.0
var float baseEntryQty = 0.0
var int pyramidAdds = 0
var int lastPositionDir = 0
var float highestSinceEntry = na
var float lowestSinceEntry = na
var float fixedStopPriceLong = na
var float fixedStopPriceShort = na
var int barsHeld = 0
var float liqBufferPct = liqBufferPctInput * 0.01
var array<float> recentPnls = array.new_float()
var table statusTable = na
var table debugTable = na
var string statusTablePosCache = ''
var string debugTablePosCache = ''
var label priceHudLabel = na
var float chandelierStop = na

newDay = dayofmonth != dayofmonth[1]
newWeek = weekofyear != weekofyear[1]

if barstate.isconfirmed
    profitDelta = strategy.netprofit - nz(strategy.netprofit[1])
    if useWallet and profitDelta > 0
        withdrawable += profitDelta * profitReservePct

equity = strategy.equity
effectiveEquity = useWallet and applyReserveToSizing ? equity - withdrawable : equity
tradableCapital := math.max(effectiveEquity, strategy.initial_capital * 0.01)

float totalAssets = tradableCapital + (useWallet ? withdrawable : 0.0)
float drawdownPct = peakEquity > 0 ? (peakEquity - equity) / peakEquity * 100.0 : 0.0
if not ruinHit and (drawdownPct >= 80 or totalAssets <= 50)
    ruinHit := true
    guardFrozen := true
    if strategy.position_size != 0
        strategy.close('포지션', comment='Ruin Stop')

peakEquity := math.max(peakEquity, equity)
dailyPeakCapital := math.max(dailyPeakCapital, tradableCapital)
weekPeakEquity := math.max(weekPeakEquity, equity)

if newDay
    dailyStartCapital := tradableCapital
    dailyPeakCapital := tradableCapital
    dailyLosses := 0
    if not ruinHit
        guardFrozen := false
if newWeek
    weekStartEquity := equity
    weekPeakEquity := equity

dailyPnl = tradableCapital - dailyStartCapital
weeklyPnl = equity - weekStartEquity
weeklyDD = weekPeakEquity > 0 ? (weekPeakEquity - equity) / weekPeakEquity * 100 : 0
totalWithdrawable = math.max(useWallet ? withdrawable : strategy.netprofit, 0.0)

dailyLossBreached = dailyLossGuard and dailyPnl <= -math.abs(dailyLossLimit)
dailyProfitReached = dailyProfitLock and dailyPnl >= math.abs(dailyProfitTarget)
weeklyProfitReached = weeklyProfitLock and weeklyPnl >= math.abs(weeklyProfitTarget)
lossStreakBreached = lossStreakGuard and lossStreak >= maxConsecutiveLoss
capitalBreached = capitalGuard and equity <= strategy.initial_capital * (1 - capitalGuardPct / 100.0)
weeklyDdBreached = maxWeeklyDD > 0 and weeklyDD >= maxWeeklyDD
lossCountBreached = maxDailyLosses > 0 and dailyLosses >= maxDailyLosses
guardFireLimit = maxGuardFires > 0 and guardFiredTotal >= maxGuardFires
atrPctVal = useVolatilityGuard ? nz(volGuardAtrPct, 0) : 0
volatilityOk = not useVolatilityGuard or (atrPctVal >= volatilityLowerPct and atrPctVal <= volatilityUpperPct)

performancePause = false
if usePerfAdaptiveRisk and array.size(recentPnls) >= parMinTrades
    wins = 0
    for i = 0 to array.size(recentPnls) - 1
        if array.get(recentPnls, i) > 0
            wins += 1
    winRate = array.size(recentPnls) > 0 ? wins / array.size(recentPnls) * 100 : 0
    if winRate <= parColdWinRate and parPauseOnCold
        performancePause := true

performancePauseActivated = performancePause and not nz(performancePause[1], false)

shouldFreeze = dailyLossBreached or dailyProfitReached or weeklyProfitReached or lossStreakBreached or capitalBreached or weeklyDdBreached or lossCountBreached or guardFireLimit or performancePause or tradableCapital < minTradableCapital or ruinHit
wasFrozen = guardFrozen
if shouldFreeze
    guardFrozen := true

guardActivated = guardFrozen and not wasFrozen
if guardActivated and strategy.position_size != 0
    lastDir := strategy.position_size > 0 ? 1 : -1
    strategy.close('포지션', comment='Guard Halt')
    guardFiredTotal += 1

alertcondition(guardActivated, title='리스크 가드 발동', message='매직1분VN: 가드 발동으로 거래 중지')
alertcondition(performancePauseActivated, title='성과 기반 중지', message='매직1분VN: 성과 기반 거래 일시 중지')

if useGuardExit and strategy.position_size != 0 and not guardActivated
    entryP = strategy.position_avg_price
    leveragePct = leverage > 0 ? 1.0 / leverage : 0.0
    if entryP > 0 and leveragePct > 0
        priceOffset = entryP * leveragePct
        liqPrice = strategy.position_size > 0 ? entryP - priceOffset : entryP + priceOffset
        if liqBufferPct > 0
            buffer = entryP * liqBufferPct
            liqPrice += strategy.position_size > 0 ? -buffer : buffer
        liqPrice := strategy.position_size > 0 ? math.max(liqPrice, tickSize) : liqPrice
        preemptPrice = strategy.position_size > 0 ? liqPrice + preemptTicks * tickSize : liqPrice - preemptTicks * tickSize
        hitGuard = strategy.position_size > 0 ? low <= preemptPrice : high >= preemptPrice
        if hitGuard
            lastDir := strategy.position_size > 0 ? 1 : -1
            strategy.close('포지션', comment='Guard Exit')
            guardFrozen := true
            guardFiredTotal += 1

canTrade = not guardFrozen and not ruinHit and volatilityOk
if time < startTime
    canTrade := false

if reentryCountdown > 0 and strategy.position_size == 0
    reentryCountdown -= 1
if reversalCountdown > 0 and strategy.position_size == 0
    reversalCountdown -= 1

if barstate.islast
    if showHudTable
        hudPosition = resolveTablePosition(hudTablePositionInput)
        if statusTablePosCache != hudTablePositionInput or na(statusTable)
            if not na(statusTable)
                table.delete(statusTable)
            statusTable := table.new(hudPosition, 2, 11, border_width=1)
        statusTablePosCache := hudTablePositionInput

        hudTextSize = resolveTextSize(hudTableTextSizeInput)
        hudHeaderSize = hudTableTextSizeInput == '작게' ? size.normal : hudTableTextSizeInput == '크게' ? size.huge : size.large

        headerBg = color.new(hudBgColorInput, 0)
        labelBg = color.new(hudBgColorInput, 35)
        neutralBg = color.new(color.gray, 85)

        capColor = tradableCapital < minTradableCapital or guardFrozen ? color.new(color.red, 55) : color.new(color.green, 65)
        dailyColor = dailyPnl > 0 ? color.new(color.green, 60) : dailyPnl < 0 ? color.new(color.red, 55) : neutralBg
        withdrawColor = totalWithdrawable > 0 ? color.new(color.green, 60) : totalWithdrawable < 0 ? color.new(color.red, 55) : neutralBg
        weeklyColor = weeklyPnl > 0 ? color.new(color.green, 60) : weeklyPnl < 0 ? color.new(color.red, 55) : neutralBg
        lossColor = lossStreak > 0 ? color.new(color.orange, 55) : color.new(color.green, 65)
        guardColor = guardFrozen ? color.new(color.red, 55) : color.new(color.green, 60)
        volColor = volatilityOk ? color.new(color.green, 60) : color.new(color.red, 55)
        perfColor = performancePause ? color.new(color.orange, 55) : color.new(color.green, 60)
        squeezeStateText = gateSqOn == 1 ? '압축 진행' : gateSqRelease ? '해제 신호' : '대기'
        squeezeColor = gateSqOn == 1 ? color.new(color.blue, 70) : gateSqRelease ? color.new(color.purple, 65) : neutralBg
        roundedBuy = math.round(buyThresh * 100.0) / 100.0
        roundedSell = math.round(sellThresh * 100.0) / 100.0
        roundedMomentum = math.round(momentum * 100.0) / 100.0
        roundedScale = math.round(thresholdScale * 100.0) / 100.0
        thresholdInfo = '매수 ' + str.tostring(roundedBuy) + ' / 매도 ' + str.tostring(roundedSell) + '\n모멘텀 ' + str.tostring(roundedMomentum) + '\n스케일 ' + str.tostring(roundedScale)

        table.cell(statusTable, 0, 0, '📊 매직1분VN 상태 HUD', text_color=hudTextColorInput, text_size=hudHeaderSize)
        table.cell(statusTable, 1, 0, '', text_color=hudTextColorInput)
        table.merge_cells(statusTable, 0, 0, 1, 0)
        table.cell_set_bgcolor(statusTable, 0, 0, headerBg)
        table.cell_set_bgcolor(statusTable, 1, 0, headerBg)

        table.cell(statusTable, 0, 1, '거래 가능 자본', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 1, labelBg)
        table.cell(statusTable, 1, 1, str.tostring(tradableCapital, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 1, capColor)

        table.cell(statusTable, 0, 2, '출금 가능 금액', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 2, labelBg)
        table.cell(statusTable, 1, 2, str.tostring(totalWithdrawable, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 2, withdrawColor)

        table.cell(statusTable, 0, 3, '일 손익', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 3, labelBg)
        table.cell(statusTable, 1, 3, str.tostring(dailyPnl, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 3, dailyColor)

        table.cell(statusTable, 0, 4, '주간 손익', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 4, labelBg)
        table.cell(statusTable, 1, 4, str.tostring(weeklyPnl, format.mintick), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 4, weeklyColor)

        table.cell(statusTable, 0, 5, '연속 손실', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 5, labelBg)
        table.cell(statusTable, 1, 5, str.tostring(lossStreak), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 5, lossColor)

        table.cell(statusTable, 0, 6, '가드 상태', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 6, labelBg)
        table.cell(statusTable, 1, 6, boolText(guardFrozen), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 6, guardColor)

        table.cell(statusTable, 0, 7, '변동성 조건', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 7, labelBg)
        table.cell(statusTable, 1, 7, boolText(volatilityOk), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 7, volColor)

        table.cell(statusTable, 0, 8, '성과 중지', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 8, labelBg)
        table.cell(statusTable, 1, 8, boolText(performancePause), text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 8, perfColor)

        table.cell(statusTable, 0, 9, '스퀴즈', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 9, labelBg)
        table.cell(statusTable, 1, 9, squeezeStateText, text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 9, squeezeColor)

        table.cell(statusTable, 0, 10, '임계·모멘텀', text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 0, 10, labelBg)
        table.cell(statusTable, 1, 10, thresholdInfo, text_color=hudTextColorInput, text_size=hudTextSize)
        table.cell_set_bgcolor(statusTable, 1, 10, labelBg)
    else
        if not na(statusTable)
            table.delete(statusTable)
        statusTable := na
        statusTablePosCache := ''

    if showDebugTable
        debugPosition = resolveTablePosition(debugTablePositionInput)
        if debugTablePosCache != debugTablePositionInput or na(debugTable)
            if not na(debugTable)
                table.delete(debugTable)
            debugTable := table.new(debugPosition, 2, 9, border_width=1)
        debugTablePosCache := debugTablePositionInput
        debugHeaderBg = color.new(hudBgColorInput, 0)
        debugLabelBg = color.new(hudBgColorInput, 45)
        debugTextColor = hudTextColorInput
        debugTextSize = size.small
        table.cell(debugTable, 0, 0, '🧪 모멘텀·플럭스 디버그', text_color=debugTextColor, text_size=size.normal)
        table.cell(debugTable, 1, 0, '', text_color=debugTextColor)
        table.merge_cells(debugTable, 0, 0, 1, 0)
        table.cell_set_bgcolor(debugTable, 0, 0, debugHeaderBg)
        table.cell_set_bgcolor(debugTable, 1, 0, debugHeaderBg)

        debugVals = array.new_string()
        array.push(debugVals, str.tostring(math.round(syntheticTR_Safe * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(thresholdScale * 1000.0) / 1000.0))
        array.push(debugVals, str.tostring(math.round(momentum * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(momSignal * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round((momentum - momSignal) * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(fluxRaw * 100.0) / 100.0))
        array.push(debugVals, str.tostring(math.round(nz(fluxCut, 0.0) * 100.0) / 100.0))

        labels = array.from('Synth TR', 'Scale', 'Momentum', 'Signal', 'Hist', 'Flux Raw', 'Flux Cut')
        for idx = 0 to array.size(labels) - 1
            label = array.get(labels, idx)
            value = array.get(debugVals, idx)
            rowIndex = idx + 1
            table.cell(debugTable, 0, rowIndex, label, text_color=debugTextColor, text_size=debugTextSize)
            table.cell(debugTable, 1, rowIndex, value, text_color=debugTextColor, text_size=debugTextSize)
            table.cell_set_bgcolor(debugTable, 0, rowIndex, debugLabelBg)
            table.cell_set_bgcolor(debugTable, 1, rowIndex, debugLabelBg)
    else
        if not na(debugTable)
            table.delete(debugTable)
        debugTable := na
        debugTablePosCache := ''

if strategy.position_size != 0
    barsHeld += 1
    if strategy.position_size > 0
        highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
        lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
    else
        lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
        highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
else
    barsHeld := 0
    highestSinceEntry := na
    lowestSinceEntry := na
    chandelierStop := na

if strategy.position_size == 0 or not useFixedStop
    fixedStopPriceLong := na
    fixedStopPriceShort := na

positionSize = strategy.position_size
avgPrice = strategy.position_avg_price
positionDir = positionSize > 0 ? 1 : positionSize < 0 ? -1 : 0
positionSizePrev = nz(strategy.position_size[1])

openedLongThisBar = false
openedShortThisBar = false

if useFixedStop
    openedLongThisBar := positionSize > 0 and positionSizePrev <= 0
    openedShortThisBar := positionSize < 0 and positionSizePrev >= 0
    if openedLongThisBar
        float fsLong = calcFixedStopPriceLong(avgPrice)
        if not na(fsLong)
            fixedStopPriceLong := fsLong
    if openedShortThisBar
        float fsShort = calcFixedStopPriceShort(avgPrice)
        if not na(fsShort)
            fixedStopPriceShort := fsShort
    if positionDir == 1 and na(fixedStopPriceLong)
        float fsLong = calcFixedStopPriceLong(avgPrice)
        if not na(fsLong)
            fixedStopPriceLong := fsLong
    if positionDir == -1 and na(fixedStopPriceShort)
        float fsShort = calcFixedStopPriceShort(avgPrice)
        if not na(fsShort)
            fixedStopPriceShort := fsShort

if openedLongThisBar
    chandelierStop := chandelierLongExit
if openedShortThisBar
    chandelierStop := chandelierShortExit

if positionDir == 1 and useChandelierExit
    chandelierStop := math.max(nz(chandelierStop[1], chandelierLongExit), chandelierLongExit)
if positionDir == -1 and useChandelierExit
    chandelierStop := math.min(nz(chandelierStop[1], chandelierShortExit), chandelierShortExit)

longCrossOk = requireCross ? crossUp : true
shortCrossOk = requireCross ? crossDown : true
entrySignalPulse = useEntryComposite ? (entryBucketClosed and entrySeriesReady) : barstate.isconfirmed
baseLongTriggerRaw = longCrossOk and momentum < buyThresh and fluxGate > 0
baseShortTriggerRaw = shortCrossOk and momentum > sellThresh and fluxGate < 0
baseLongTrigger = entrySignalPulse and baseLongTriggerRaw
baseShortTrigger = entrySignalPulse and baseShortTriggerRaw
baseLongSignal = debugForceLong or baseLongTrigger
baseShortSignal = debugForceShort or baseShortTrigger

longOk = true
shortOk = true
if useAdx
    longOk := longOk and adxSeries > adxThresh
    shortOk := shortOk and adxSeries > adxThresh
if useObv
    longOk := longOk and obvSlopeVal > 0
    shortOk := shortOk and obvSlopeVal < 0
if useAtrDiff
    longOk := longOk and atrDiff > 0
    shortOk := shortOk and atrDiff < 0
if useHtfTrend
    longOk := longOk and htfTrendUp
    shortOk := shortOk and htfTrendDown
if useHmaFilter
    hmaLongOk = not na(entryCloseSeries) and not na(hmaValue) and entryCloseSeries > hmaValue
    hmaShortOk = not na(entryCloseSeries) and not na(hmaValue) and entryCloseSeries < hmaValue
    longOk := longOk and hmaLongOk
    shortOk := shortOk and hmaShortOk
if useRangeFilter
    longOk := longOk and not inRangeBox
    shortOk := shortOk and not inRangeBox
if useDistanceGuard
    longOk := longOk and (atrSeries(distanceAtrLen) > 0) and ((math.abs(close - ta.sma(close, distanceAtrLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr) and ((math.abs(close - ta.ema(close, distanceTrendLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr)
    shortOk := shortOk and (atrSeries(distanceAtrLen) > 0) and ((math.abs(close - ta.sma(close, distanceAtrLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr) and ((math.abs(close - ta.ema(close, distanceTrendLen)) / atrSeries(distanceAtrLen)) <= distanceMaxAtr)
if useDisparityGuard
    longOk := longOk and disparityOk
    shortOk := shortOk and disparityOk
longOk := longOk and regimeLongOk
shortOk := shortOk and regimeShortOk

if useSqzGate
    longOk := longOk and gateSqValid
    shortOk := shortOk and gateSqValid

enterLong = allowLongEntry and canTrade and baseLongSignal and longOk and positionDir == 0 and reentryCountdown == 0
enterShort = allowShortEntry and canTrade and baseShortSignal and shortOk and positionDir == 0 and reentryCountdown == 0

alertcondition(enterLong, title='롱 진입 신호', message='매직1분VN: 롱 진입 조건 충족')
alertcondition(enterShort, title='숏 진입 신호', message='매직1분VN: 숏 진입 조건 충족')

if not barstate.isconfirmed
    enterLong := false
    enterShort := false

baseLongSignalConfirmed = barstate.isconfirmed ? baseLongSignal : false
baseShortSignalConfirmed = barstate.isconfirmed ? baseShortSignal : false

if useReversal and reversalCountdown == 0 and positionDir == 0 and lastDir != 0 and canTrade and barstate.isconfirmed
    if lastDir == 1
        enterShort := true
    else if lastDir == -1
        enterLong := true
    lastDir := 0

exitLong = false
exitShort = false
exitLongReason = ''
exitShortReason = ''
string longExitReasonLabel = ''
string shortExitReasonLabel = ''

translateExitReason(reason, isLong) =>
    dirLabel = isLong ? '롱' : '숏'
    switch reason
        'opposite' => '반대 신호 청산 (' + dirLabel + ')'
        'mom_fade' => '모멘텀 약화 청산 (' + dirLabel + ')'
        'time_stop' => '최대 보유 시간 초과 청산 (' + dirLabel + ')'
        'kasa_exit' => 'KASA 조건 충족 청산 (' + dirLabel + ')'
        'shock' => '변동성 쇼크 청산 (' + dirLabel + ')'
        'band_exit' => 'BB/KC 밴드 청산 (' + dirLabel + ')'
        => '기타 청산 (' + dirLabel + ')'

swingLowForStop = ta.lowest(low, stopLookback)[1]
swingHighForStop = ta.highest(high, stopLookback)[1]
atrTrailSeries = atrSeries(atrTrailLen)
dynFactor = 1.0

float stopLong = na
float stopShort = na
float targetLong = na
float targetShort = na

if exitOpposite and barstate.isconfirmed and strategy.position_size != 0
    canExitOpp = barsHeld >= minHoldBarsInput
    if positionDir > 0 and canExitOpp and baseShortSignalConfirmed and shortOk
        exitLong := true
        exitLongReason := 'opposite'
        longExitReasonLabel := translateExitReason(exitLongReason, true)
        strategy.close('포지션', comment='반대 신호 청산 (롱)')
        reentryCountdown := math.max(reentryBars, 1)
    if positionDir < 0 and canExitOpp and baseLongSignalConfirmed and longOk
        exitShort := true
        exitShortReason := 'opposite'
        shortExitReasonLabel := translateExitReason(exitShortReason, false)
        strategy.close('포지션', comment='반대 신호 청산 (숏)')
        reentryCountdown := math.max(reentryBars, 1)

// [수정] 모멘텀 페이드 로직 (entrySignalPulse에 맞춰 타이밍 수정)
if useMomFade and entrySignalPulse and strategy.position_size != 0 and not exitLong and not exitShort
    canExitFade = barsHeld >= minHoldBarsInput
    // 롱 포지션: 모멘텀이 momFadeMinAbs 값 위에서 감소하기 시작할 때
    if positionDir > 0 and canExitFade and (momentum < momentum[1]) and (momentum > momFadeMinAbs)
        exitLong := true
        exitLongReason := 'mom_fade'
        longExitReasonLabel := translateExitReason(exitLongReason, true)
        strategy.close('포지션', comment='모멘텀 페이드 (롱)')
        reentryCountdown := math.max(reentryBars, 1)

    // 숏 포지션: 모멘텀이 -momFadeMinAbs 값 아래에서 증가하기 시작할 때
    if positionDir < 0 and canExitFade and (momentum > momentum[1]) and (momentum < -momFadeMinAbs)
        exitShort := true
        exitShortReason := 'mom_fade'
        shortExitReasonLabel := translateExitReason(exitShortReason, false)
        strategy.close('포지션', comment='모멘텀 페이드 (숏)')
        reentryCountdown := math.max(reentryBars, 1)

if positionDir > 0
    if useStopLoss
        stopLong := maxIgnoreNaN(stopLong, swingLowForStop)
    if useFixedStop and not na(fixedStopPriceLong)
        stopLong := maxIgnoreNaN(stopLong, fixedStopPriceLong)
    if useChandelierExit and not na(chandelierStop)
        stopLong := maxIgnoreNaN(stopLong, chandelierStop)
    if useSarExit and not na(sarValue)
        stopLong := maxIgnoreNaN(stopLong, sarValue)
    if useChannelStop and not na(channelStopLower)
        stopLong := maxIgnoreNaN(stopLong, channelStopLower)
    if useBreakevenStop and not na(highestSinceEntry) and not na(atrTrailSeries)
        move = highestSinceEntry - avgPrice
        trigger = atrTrailSeries * breakevenMult * dynFactor
        if move >= trigger
            stopLong := maxIgnoreNaN(stopLong, avgPrice)
    if useBeTiers and not na(highestSinceEntry)
        atrSeed = atrOsc
        if atrSeed > 0 and highestSinceEntry - avgPrice >= atrSeed
            stopLong := maxIgnoreNaN(stopLong, avgPrice)
    if useAtrProfit and not na(atrTrailSeries)
        targetLong := avgPrice + atrTrailSeries * atrProfitMult * dynFactor
else if positionDir < 0
    if useStopLoss
        stopShort := minIgnoreNaN(stopShort, swingHighForStop)
    if useFixedStop and not na(fixedStopPriceShort)
        stopShort := minIgnoreNaN(stopShort, fixedStopPriceShort)
    if useChandelierExit and not na(chandelierStop)
        stopShort := minIgnoreNaN(stopShort, chandelierStop)
    if useSarExit and not na(sarValue)
        stopShort := minIgnoreNaN(stopShort, sarValue)
    if useChannelStop and not na(channelStopUpper)
        stopShort := minIgnoreNaN(stopShort, channelStopUpper)
    if useBreakevenStop and not na(lowestSinceEntry) and not na(atrTrailSeries)
        move = avgPrice - lowestSinceEntry
        trigger = atrTrailSeries * breakevenMult * dynFactor
        if move >= trigger
            stopShort := minIgnoreNaN(stopShort, avgPrice)
    if useBeTiers and not na(lowestSinceEntry)
        atrSeed = atrOsc
        if atrSeed > 0 and avgPrice - lowestSinceEntry >= atrSeed
            stopShort := minIgnoreNaN(stopShort, avgPrice)
    if useAtrProfit and not na(atrTrailSeries)
        targetShort := avgPrice - atrTrailSeries * atrProfitMult * dynFactor

bandExitArmed = useBandExit and barsHeld >= bandExitMinBars
bandLongTriggered = bandExitArmed and ((not na(bbUpper) and high >= bbUpper) or (not na(kcUpper) and high >= kcUpper))
bandShortTriggered = bandExitArmed and ((not na(bbLower) and low <= bbLower) or (not na(kcLower) and low <= kcLower))

if not exitLong and positionDir > 0 and bandLongTriggered
    exitLong := true
    exitLongReason := 'band_exit'
    longExitReasonLabel := translateExitReason(exitLongReason, true)
    strategy.close('포지션', comment='BB/KC 밴드 출구 (롱)')
if not exitShort and positionDir < 0 and bandShortTriggered
    exitShort := true
    exitShortReason := 'band_exit'
    shortExitReasonLabel := translateExitReason(exitShortReason, false)
    strategy.close('포지션', comment='BB/KC 밴드 출구 (숏)')

if positionDir > 0 and not exitLong
    if not na(stopLong) and low <= stopLong
        string reason = "손절"
        if useSarExit and not na(sarValue) and stopLong == sarValue
            reason := "SAR 손절"
        else if useChandelierExit and not na(chandelierStop) and stopLong == chandelierStop
            reason := "샹들리에 손절"
        else if useFixedStop and not na(fixedStopPriceLong) and stopLong == fixedStopPriceLong
            reason := "고정 손절"
        else if useStopLoss and stopLong == swingLowForStop
            reason := "스윙 손절"
        else if useChannelStop and stopLong == channelStopLower
            reason := "채널 손절"
        strategy.close('포지션', comment=reason + ' (롱)')
    if not na(targetLong) and high >= targetLong
        strategy.close('포지션', comment='ATR 익절 (롱)')

if positionDir < 0 and not exitShort
    if not na(stopShort) and high >= stopShort
        string reason = "손절"
        if useSarExit and not na(sarValue) and stopShort == sarValue
            reason := "SAR 손절"
        else if useChandelierExit and not na(chandelierStop) and stopShort == chandelierStop
            reason := "샹들리에 손절"
        else if useFixedStop and not na(fixedStopPriceShort) and stopShort == fixedStopPriceShort
            reason := "고정 손절"
        else if useStopLoss and stopShort == swingHighForStop
            reason := "스윙 손절"
        else if useChannelStop and stopShort == channelStopUpper
            reason := "채널 손절"
        strategy.close('포지션', comment=reason + ' (숏)')
    if not na(targetShort) and low <= targetShort
        strategy.close('포지션', comment='ATR 익절 (숏)')

if exitLong
    label.new(bar_index, 0, text=longExitReasonLabel, yloc=yloc.price, color=color.new(color.maroon, 70), textcolor=color.white, style=label.style_label_down, size=size.tiny)

if exitShort
    label.new(bar_index, 0, text=shortExitReasonLabel, yloc=yloc.price, color=color.new(color.teal, 70), textcolor=color.white, style=label.style_label_up, size=size.tiny)

exitLongReasonSeries = exitLong ? longExitReasonLabel : na
exitShortReasonSeries = exitShort ? shortExitReasonLabel : na
alertcondition(exitLong, title='롱 청산 신호', message='매직1분VN: 롱 청산 — 조건 충족')
alertcondition(exitShort, title='숏 청산 신호', message='매직1분VN: 숏 청산 — 조건 충족')

calcOrderSize(price, stopDistance, riskMult) =>
    result = 0.0
    if price > 0
        effectiveScale = baseRiskPct
        if useDrawdownScaling and peakEquity > 0
            dd = (peakEquity - equity) / peakEquity * 100
            if dd > drawdownTriggerPct
                effectiveScale *= drawdownRiskScale
        if usePerfAdaptiveRisk and array.size(recentPnls) >= parMinTrades
            wins = 0
            for i = 0 to array.size(recentPnls) - 1
                if array.get(recentPnls, i) > 0
                    wins += 1
            winRate = array.size(recentPnls) > 0 ? wins / array.size(recentPnls) * 100 : 0
            if winRate >= parHotWinRate
                effectiveScale *= parHotMult
            else if winRate <= parColdWinRate
                effectiveScale *= parColdMult
        mult = math.max(riskMult, 0.0)
        if not useSizingOverride
            pctToUse = math.max(baseQtyPercent * mult * (baseRiskPct > 0 ? effectiveScale / baseRiskPct : 1.0), 0.0)
            capitalPortion = tradableCapital * pctToUse / 100.0
            result := (capitalPortion * leverage) / price
        else if sizingMode == '자본 비율'
            pctToUse = math.max(advancedPercent * mult, 0.0)
            capitalPortion = tradableCapital * pctToUse / 100.0
            result := (capitalPortion * leverage) / price
        else if sizingMode == '고정 금액 (USD)'
            usdToUse = math.max(fixedUsdAmount * mult, 0.0)
            result := (usdToUse * leverage) / price
        else if sizingMode == '고정 계약'
            result := math.max(fixedContractSize * mult, 0.0)
        else if sizingMode == '리스크 기반'
            if riskSizingType == '고정 계약'
                result := math.max(riskContractSize * mult, 0.0)
            else if stopDistance > 0 and not na(stopDistance)
                riskPct = math.max(effectiveScale * mult, 0.0)
                riskCapital = tradableCapital * riskPct / 100.0
                result := riskCapital > 0 ? riskCapital / (stopDistance + slipValue) : 0.0
    result

if positionDir == 0
    baseEntryQty := 0.0
    pyramidAdds := 0
    if enterLong
        float entryPrice = close
        float prospectiveStop = calcProspectiveStopLong(entryPrice, atrTrailSeries, dynFactor, swingLowForStop, channelStopLower)
        float stopDist = not na(prospectiveStop) ? entryPrice - prospectiveStop : na
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        float qty = calcOrderSize(entryPrice, stopForSize, 1.0)
        if guardOk and qty > 0
            strategy.entry('포지션', strategy.long, qty=qty)
            float fsLong = calcFixedStopPriceLong(entryPrice)
            if not na(fsLong)
                fixedStopPriceLong := fsLong
            lastEntryPrice := close
            lastEntryQty := qty
            baseEntryQty := qty
            pyramidAdds := 0
            lastPositionDir := 1
            highestSinceEntry := high
            lowestSinceEntry := low
            reversalCountdown := int(reversalDelaySec / 60.0)
            reentryCountdown := reentryBars
    if enterShort
        float entryPrice = close
        float prospectiveStop = calcProspectiveStopShort(entryPrice, atrTrailSeries, dynFactor, swingHighForStop, channelStopUpper)
        float stopDist = not na(prospectiveStop) ? prospectiveStop - entryPrice : na
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        float qty = calcOrderSize(entryPrice, stopForSize, 1.0)
        if guardOk and qty > 0
            strategy.entry('포지션', strategy.short, qty=qty)
            float fsShort = calcFixedStopPriceShort(entryPrice)
            if not na(fsShort)
                fixedStopPriceShort := fsShort
            lastEntryPrice := close
            lastEntryQty := qty
            baseEntryQty := qty
            pyramidAdds := 0
            lastPositionDir := -1
            highestSinceEntry := high
            lowestSinceEntry := low
            reversalCountdown := int(reversalDelaySec / 60.0)
            reentryCountdown := reentryBars
else if usePyramiding and pyramidAdds == 0 and canTrade and reentryCountdown == 0 and barstate.isconfirmed
    if positionDir > 0 and allowLongEntry and baseLongSignal and longOk
        float addQty = baseEntryQty > 0 ? baseEntryQty : lastEntryQty
        float prospectiveStop = calcProspectiveStopLong(close, atrTrailSeries, dynFactor, swingLowForStop, channelStopLower)
        float stopDist = not na(prospectiveStop) ? close - prospectiveStop : atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        if guardOk and addQty > 0
            strategy.entry('포지션', strategy.long, qty=addQty)
            float fsLong = calcFixedStopPriceLong(close)
            if not na(fsLong)
                fixedStopPriceLong := na(fixedStopPriceLong) ? fsLong : math.max(fixedStopPriceLong, fsLong)
            pyramidAdds := 1
            lastEntryPrice := strategy.position_avg_price
            lastEntryQty := strategy.position_size
            highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
            lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)
    else if positionDir < 0 and allowShortEntry and baseShortSignal and shortOk
        float addQty = baseEntryQty > 0 ? baseEntryQty : lastEntryQty
        float prospectiveStop = calcProspectiveStopShort(close, atrTrailSeries, dynFactor, swingHighForStop, channelStopUpper)
        float stopDist = not na(prospectiveStop) ? prospectiveStop - close : atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := atrOsc
        if na(stopDist) or stopDist <= 0
            stopDist := tickSize
        float stopForSize = math.max(stopDist, tickSize)
        guardOk = not useStopDistanceGuard or na(atrOsc) or stopForSize <= atrOsc * maxStopAtrMult
        if guardOk and addQty > 0
            strategy.entry('포지션', strategy.short, qty=addQty)
            float fsShort = calcFixedStopPriceShort(close)
            if not na(fsShort)
                fixedStopPriceShort := na(fixedStopPriceShort) ? fsShort : math.min(fixedStopPriceShort, fsShort)
            pyramidAdds := 1
            lastEntryPrice := strategy.position_avg_price
            lastEntryQty := strategy.position_size
            highestSinceEntry := na(highestSinceEntry) ? high : math.max(highestSinceEntry, high)
            lowestSinceEntry := na(lowestSinceEntry) ? low : math.min(lowestSinceEntry, low)

var int prevClosedTrades = 0
currentClosedTrades = strategy.closedtrades
if currentClosedTrades > prevClosedTrades
    for idx = prevClosedTrades to currentClosedTrades - 1
        tradeProfit = strategy.closedtrades.profit(idx)
        if tradeProfit < 0
            lossStreak += 1
            dailyLosses += 1
        else if tradeProfit > 0
            lossStreak := 0
        if usePerfAdaptiveRisk
            array.push(recentPnls, tradeProfit)
            if array.size(recentPnls) > parLookback
                array.shift(recentPnls)
    prevClosedTrades := currentClosedTrades

if positionDir == 0 and (exitLong or exitShort)
    lastDir := lastPositionDir

// ─────────────────────────────────────────────────────────────────────────────
// HUD 출력 (테이블 HUD만 활성화)
if not na(priceHudLabel)
    label.delete(priceHudLabel)
    priceHudLabel := na

// ─────────────────────────────────────────────────────────────────────────────
// 시각화 플롯 & 하이라이트
momentumPlotValue = barstate.isconfirmed ? momentum : nz(momentum[1], momentum)
signalPlotValue = barstate.isconfirmed ? momSignal : nz(momSignal[1], momSignal)
buyThreshPlotValue = barstate.isconfirmed ? buyThresh : nz(buyThresh[1], buyThresh)
sellThreshPlotValue = barstate.isconfirmed ? sellThresh : nz(sellThresh[1], sellThresh)

momentumPlotSeries = plot(showMomentumDecorators ? momentumPlotValue : na, title='Momentum (확정)', color=color.new(color.teal, 0), linewidth=2)
signalPlotSeries = plot(showMomentumDecorators ? signalPlotValue : na, title='Signal (확정)', color=color.new(color.orange, 0), linewidth=1)
buyThreshSeries = plot(showMomentumDecorators ? buyThreshPlotValue : na, title='Buy Threshold', color=color.new(color.green, 40), linewidth=1)
sellThreshSeries = plot(showMomentumDecorators ? sellThreshPlotValue : na, title='Sell Threshold', color=color.new(color.red, 40), linewidth=1)
hline(0, 'Momentum Zero', color=color.new(color.gray, 70))

fill(momentumPlotSeries, signalPlotSeries, color=showMomentumDecorators ? color.new(color.teal, 88) : na)
fill(buyThreshSeries, sellThreshSeries, color=showMomentumDecorators ? color.new(color.purple, 92) : na)

crossMarkerEnabled = showMomentumDecorators and showMomentumCrossMarkers
crossUpMarkerValue = crossMarkerEnabled and barstate.isconfirmed and crossUp ? momentumPlotValue : na
crossDownMarkerValue = crossMarkerEnabled and barstate.isconfirmed and crossDown ? momentumPlotValue : na
plotshape(crossUpMarkerValue,   title='모멘텀 크로스 업',
      style=shape.circle, location=location.absolute,
      color=color.new(color.lime, 0), size=size.tiny, text='', textcolor=color.white)

plotshape(crossDownMarkerValue, title='모멘텀 크로스 다운',
      style=shape.circle, location=location.absolute,
      color=color.new(color.red, 0),  size=size.tiny, text='', textcolor=color.white)
longSignalMarker = showSignalMarkers and baseLongSignalConfirmed and longOk ? buyThreshPlotValue : na
shortSignalMarker = showSignalMarkers and baseShortSignalConfirmed and shortOk ? sellThreshPlotValue : na
plotshape(longSignalMarker, title='롱 조건 충족', style=shape.triangleup, location=location.absolute, color=color.new(color.lime, 0), size=size.tiny, text='롱', textcolor=color.white)
plotshape(shortSignalMarker, title='숏 조건 충족', style=shape.triangledown, location=location.absolute, color=color.new(color.red, 0), size=size.tiny, text='숏', textcolor=color.white)

sqzActiveBg = showSqueezeHighlight and gateSqOn == 1 ? color.new(color.blue, 90) : na
sqzReleaseBg = showSqueezeHighlight and gateSqRelease ? color.new(color.purple, 88) : na
bgcolor(sqzActiveBg, title='Squeeze Active BG')
bgcolor(sqzReleaseBg, title='Squeeze Release BG')
bgcolor(guardFrozen ? color.new(color.red, 90) : na, title='Guard Freeze BG')

